// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "../src/List.bs.js";
import * as Unix from "../tests/Unix.bs.js";
import * as Bytes from "bs-platform/lib/es6/bytes.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Deque from "../src/deque.bs.js";
import * as $$Buffer from "bs-platform/lib/es6/buffer.js";
import * as Printf from "bs-platform/lib/es6/printf.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Printexc from "bs-platform/lib/es6/printexc.js";
import * as Caml_bytes from "bs-platform/lib/es6/caml_bytes.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";

var empty = "";

function $at(a, b) {
  return a + b;
}

function of_string(s) {
  return s;
}

function to_string(s) {
  return s;
}

var Build_string = {
  empty: empty,
  $at: $at,
  of_string: of_string,
  to_string: to_string
};

function Fold_to_string(F) {
  var to_string = function (ss) {
    var n = Curry._3(F.fold_left, (function (acc, s) {
            return acc + s.length | 0;
          }), 0, ss);
    var buf = Caml_bytes.caml_create_bytes(n);
    Curry._3(F.fold_left, (function (i, s) {
            var n = s.length;
            Bytes.blit_string(s, 0, buf, i, n);
            return i + n | 0;
          }), 0, ss);
    return Bytes.to_string(buf);
  };
  return {
          to_string: to_string
        };
}

var $at$1 = List.append;

function of_string$1(s) {
  return {
          hd: s,
          tl: /* [] */0
        };
}

function to_string$1(ss) {
  var n = List.fold_left((function (acc, s) {
          return acc + s.length | 0;
        }), 0, ss);
  var buf = Caml_bytes.caml_create_bytes(n);
  List.fold_left((function (i, s) {
          var n = s.length;
          Bytes.blit_string(s, 0, buf, i, n);
          return i + n | 0;
        }), 0, ss);
  return Bytes.to_string(buf);
}

var Build_list = {
  empty: /* [] */0,
  $at: $at$1,
  of_string: of_string$1,
  to_string: to_string$1
};

function $at$2(a, b) {
  return List.rev_append(List.rev(a), b);
}

var Build_list_safe = {
  empty: /* [] */0,
  of_string: of_string$1,
  to_string: to_string$1,
  $at: $at$2
};

function empty$1(xs) {
  return xs;
}

function $at$3(a, b, xs) {
  return Curry._1(a, Curry._1(b, xs));
}

function of_string$2(s, xs) {
  return {
          hd: s,
          tl: xs
        };
}

function to_string$2(ss) {
  return to_string$1(Curry._1(ss, /* [] */0));
}

var Build_dlist = {
  empty: empty$1,
  $at: $at$3,
  of_string: of_string$2,
  to_string: to_string$2
};

function fold_left(f, _z, _s) {
  while(true) {
    var s = _s;
    var z = _z;
    if (typeof s === "number") {
      return z;
    }
    if (s.TAG === /* Single */0) {
      return Curry._2(f, z, s._0);
    }
    _s = s._1;
    _z = fold_left(f, z, s._0);
    continue ;
  };
}

var F = {
  fold_left: fold_left
};

function $at$4(a, b) {
  if (typeof a === "number") {
    return b;
  } else if (typeof b === "number") {
    return a;
  } else {
    return {
            TAG: /* Concat */1,
            _0: a,
            _1: b
          };
  }
}

function of_string$3(s) {
  return {
          TAG: /* Single */0,
          _0: s
        };
}

function to_string$3(ss) {
  var n = fold_left((function (acc, s) {
          return acc + s.length | 0;
        }), 0, ss);
  var buf = Caml_bytes.caml_create_bytes(n);
  fold_left((function (i, s) {
          var n = s.length;
          Bytes.blit_string(s, 0, buf, i, n);
          return i + n | 0;
        }), 0, ss);
  return Bytes.to_string(buf);
}

var Build_tree = {
  F: F,
  empty: /* Empty */0,
  $at: $at$4,
  of_string: of_string$3,
  to_string: to_string$3
};

var $at$5 = Deque.append;

function of_string$4(s) {
  return Deque.cons(s, Deque.empty);
}

function to_string$4(ss) {
  var n = Deque.fold_left((function (acc, s) {
          return acc + s.length | 0;
        }), 0, ss);
  var buf = Caml_bytes.caml_create_bytes(n);
  Deque.fold_left((function (i, s) {
          var n = s.length;
          Bytes.blit_string(s, 0, buf, i, n);
          return i + n | 0;
        }), 0, ss);
  return Bytes.to_string(buf);
}

var Build_deque = {
  empty: Deque.empty,
  $at: $at$5,
  of_string: of_string$4,
  to_string: to_string$4
};

var empty$2 = Deque.Steque.empty;

function $at$6(a, b) {
  return Deque.Steque.append(a, b);
}

function of_string$5(s) {
  return Deque.Steque.cons(s, Deque.Steque.empty);
}

function to_string$5(ss) {
  var n = Curry._3(Deque.Steque.fold_left, (function (acc, s) {
          return acc + s.length | 0;
        }), 0, ss);
  var buf = Caml_bytes.caml_create_bytes(n);
  Curry._3(Deque.Steque.fold_left, (function (i, s) {
          var n = s.length;
          Bytes.blit_string(s, 0, buf, i, n);
          return i + n | 0;
        }), 0, ss);
  return Bytes.to_string(buf);
}

var Build_steque = {
  Deque: undefined,
  empty: empty$2,
  $at: $at$6,
  of_string: of_string$5,
  to_string: to_string$5
};

function bench(name, f) {
  var t0 = Unix.gettimeofday(undefined);
  var match;
  try {
    match = [
      true,
      Curry._1(f, undefined)
    ];
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    match = [
      false,
      Printexc.to_string(e)
    ];
  }
  var str = match[1];
  var ok = match[0];
  var t1 = Unix.gettimeofday(undefined);
  Curry._3(Printf.printf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: {
                TAG: /* Lit_padding */0,
                _0: /* Right */1,
                _1: 16
              },
              _1: {
                TAG: /* String_literal */11,
                _0: ": ",
                _1: {
                  TAG: /* Float */8,
                  _0: /* Float_f */0,
                  _1: /* No_padding */0,
                  _2: /* Lit_precision */{
                    _0: 3
                  },
                  _3: {
                    TAG: /* String_literal */11,
                    _0: " s -- ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '\n' */10,
                        _1: {
                          TAG: /* Flush */10,
                          _0: /* End_of_format */0
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "%16s: %.3f s -- %s\n%!"
          }), name, t1 - t0, ok ? "length " + String(str.length) : str);
  if (ok) {
    return str;
  }
  
}

function Test(Builder) {
  var popen = Curry._1(Builder.of_string, " begin ");
  var pclose = Curry._1(Builder.of_string, " end ");
  var parens = function (x) {
    return Curry._2(Builder.$at, popen, Curry._2(Builder.$at, x, pclose));
  };
  var parens_in = bench("parens", (function (param) {
          var go = function (_acc, _n) {
            while(true) {
              var n = _n;
              var acc = _acc;
              if (n === 0) {
                return acc;
              }
              _n = n - 1 | 0;
              _acc = parens(acc);
              continue ;
            };
          };
          return Curry._1(Builder.to_string, go(Builder.empty, 20000));
        }));
  var fibonacci = bench("fibonacci", (function (param) {
          var go = function (_a, _b, _n) {
            while(true) {
              var n = _n;
              var b = _b;
              var a = _a;
              if (n === 0) {
                return a;
              }
              _n = n - 1 | 0;
              _b = parens(a);
              _a = parens(Curry._2(Builder.$at, a, b));
              continue ;
            };
          };
          return Curry._1(Builder.to_string, go(Curry._1(Builder.of_string, "1"), Curry._1(Builder.of_string, "0"), 32));
        }));
  return {
          popen: popen,
          pclose: pclose,
          parens: parens,
          parens_in: parens_in,
          fibonacci: fibonacci
        };
}

function header(name) {
  return Curry._2(Printf.printf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "-- ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* ' ' */32,
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '\n' */10,
                            _1: {
                              TAG: /* Flush */10,
                              _0: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "-- %s %s\n%!"
                }), name, $$String.make((70 - name.length | 0) - 4 | 0, /* '-' */45));
}

header("String");

var popen = " begin ";

var pclose = " end ";

function parens(x) {
  return popen + (x + pclose);
}

var parens_in = bench("parens", (function (param) {
        var _acc = empty;
        var _n = 20000;
        while(true) {
          var n = _n;
          var acc = _acc;
          if (n === 0) {
            return acc;
          }
          _n = n - 1 | 0;
          _acc = parens(acc);
          continue ;
        };
      }));

var fibonacci = bench("fibonacci", (function (param) {
        var _a = "1";
        var _b = "0";
        var _n = 32;
        while(true) {
          var n = _n;
          var b = _b;
          var a = _a;
          if (n === 0) {
            return a;
          }
          _n = n - 1 | 0;
          _b = parens(a);
          _a = parens(a + b);
          continue ;
        };
      }));

var Test_string = {
  popen: popen,
  pclose: pclose,
  parens: parens,
  parens_in: parens_in,
  fibonacci: fibonacci
};

Printf.printf(/* Format */{
      _0: {
        TAG: /* Char_literal */12,
        _0: /* '\n' */10,
        _1: {
          TAG: /* Flush */10,
          _0: /* End_of_format */0
        }
      },
      _1: "\n%!"
    });

function Test_check(Builder) {
  var popen = Curry._1(Builder.of_string, " begin ");
  var pclose = Curry._1(Builder.of_string, " end ");
  var parens = function (x) {
    return Curry._2(Builder.$at, popen, Curry._2(Builder.$at, x, pclose));
  };
  var parens_in$1 = bench("parens", (function (param) {
          var go = function (_acc, _n) {
            while(true) {
              var n = _n;
              var acc = _acc;
              if (n === 0) {
                return acc;
              }
              _n = n - 1 | 0;
              _acc = parens(acc);
              continue ;
            };
          };
          return Curry._1(Builder.to_string, go(Builder.empty, 20000));
        }));
  var fibonacci$1 = bench("fibonacci", (function (param) {
          var go = function (_a, _b, _n) {
            while(true) {
              var n = _n;
              var b = _b;
              var a = _a;
              if (n === 0) {
                return a;
              }
              _n = n - 1 | 0;
              _b = parens(a);
              _a = parens(Curry._2(Builder.$at, a, b));
              continue ;
            };
          };
          return Curry._1(Builder.to_string, go(Curry._1(Builder.of_string, "1"), Curry._1(Builder.of_string, "0"), 32));
        }));
  var T = {
    popen: popen,
    pclose: pclose,
    parens: parens,
    parens_in: parens_in$1,
    fibonacci: fibonacci$1
  };
  if (!Caml_obj.caml_equal(parens_in$1, parens_in)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "string_builder.re",
            184,
            4
          ],
          Error: new Error()
        };
  }
  if (!(fibonacci$1 === undefined || Caml_obj.caml_equal(fibonacci$1, fibonacci))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "string_builder.re",
            185,
            4
          ],
          Error: new Error()
        };
  }
  return {
          T: T
        };
}

header("List");

var popen$1 = {
  hd: " begin ",
  tl: /* [] */0
};

var pclose$1 = {
  hd: " end ",
  tl: /* [] */0
};

function parens$1(x) {
  return List.append(popen$1, List.append(x, pclose$1));
}

var parens_in$1 = bench("parens", (function (param) {
        var go = function (_acc, _n) {
          while(true) {
            var n = _n;
            var acc = _acc;
            if (n === 0) {
              return acc;
            }
            _n = n - 1 | 0;
            _acc = parens$1(acc);
            continue ;
          };
        };
        return to_string$1(go(/* [] */0, 20000));
      }));

var fibonacci$1 = bench("fibonacci", (function (param) {
        var go = function (_a, _b, _n) {
          while(true) {
            var n = _n;
            var b = _b;
            var a = _a;
            if (n === 0) {
              return a;
            }
            _n = n - 1 | 0;
            _b = parens$1(a);
            _a = parens$1(List.append(a, b));
            continue ;
          };
        };
        return to_string$1(go({
                        hd: "1",
                        tl: /* [] */0
                      }, {
                        hd: "0",
                        tl: /* [] */0
                      }, 32));
      }));

var T = {
  popen: popen$1,
  pclose: pclose$1,
  parens: parens$1,
  parens_in: parens_in$1,
  fibonacci: fibonacci$1
};

if (!Caml_obj.caml_equal(parens_in$1, parens_in)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          184,
          4
        ],
        Error: new Error()
      };
}

if (!(fibonacci$1 === undefined || Caml_obj.caml_equal(fibonacci$1, fibonacci))) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          185,
          4
        ],
        Error: new Error()
      };
}

var Test_list = {
  T: T
};

Printf.printf(/* Format */{
      _0: {
        TAG: /* Char_literal */12,
        _0: /* '\n' */10,
        _1: {
          TAG: /* Flush */10,
          _0: /* End_of_format */0
        }
      },
      _1: "\n%!"
    });

header("List_safe (no Stack_overflow on append)");

var popen$2 = {
  hd: " begin ",
  tl: /* [] */0
};

var pclose$2 = {
  hd: " end ",
  tl: /* [] */0
};

function parens$2(x) {
  var b = List.rev_append(List.rev(x), pclose$2);
  return List.rev_append(List.rev(popen$2), b);
}

var parens_in$2 = bench("parens", (function (param) {
        var go = function (_acc, _n) {
          while(true) {
            var n = _n;
            var acc = _acc;
            if (n === 0) {
              return acc;
            }
            _n = n - 1 | 0;
            _acc = parens$2(acc);
            continue ;
          };
        };
        return to_string$1(go(/* [] */0, 20000));
      }));

var fibonacci$2 = bench("fibonacci", (function (param) {
        var go = function (_a, _b, _n) {
          while(true) {
            var n = _n;
            var b = _b;
            var a = _a;
            if (n === 0) {
              return a;
            }
            _n = n - 1 | 0;
            _b = parens$2(a);
            _a = parens$2(List.rev_append(List.rev(a), b));
            continue ;
          };
        };
        return to_string$1(go({
                        hd: "1",
                        tl: /* [] */0
                      }, {
                        hd: "0",
                        tl: /* [] */0
                      }, 32));
      }));

var T$1 = {
  popen: popen$2,
  pclose: pclose$2,
  parens: parens$2,
  parens_in: parens_in$2,
  fibonacci: fibonacci$2
};

if (!Caml_obj.caml_equal(parens_in$2, parens_in)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          184,
          4
        ],
        Error: new Error()
      };
}

if (!(fibonacci$2 === undefined || Caml_obj.caml_equal(fibonacci$2, fibonacci))) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          185,
          4
        ],
        Error: new Error()
      };
}

var Test_list_safe = {
  T: T$1
};

Printf.printf(/* Format */{
      _0: {
        TAG: /* Char_literal */12,
        _0: /* '\n' */10,
        _1: {
          TAG: /* Flush */10,
          _0: /* End_of_format */0
        }
      },
      _1: "\n%!"
    });

header("Diff list");

function popen$3(param) {
  return {
          hd: " begin ",
          tl: param
        };
}

function pclose$3(param) {
  return {
          hd: " end ",
          tl: param
        };
}

function parens$3(x) {
  return function (param) {
    return {
            hd: " begin ",
            tl: Curry._1(x, {
                  hd: " end ",
                  tl: param
                })
          };
  };
}

var parens_in$3 = bench("parens", (function (param) {
        var go = function (_acc, _n) {
          while(true) {
            var n = _n;
            var acc = _acc;
            if (n === 0) {
              return acc;
            }
            _n = n - 1 | 0;
            _acc = parens$3(acc);
            continue ;
          };
        };
        var ss = go(empty$1, 20000);
        return to_string$1(Curry._1(ss, /* [] */0));
      }));

var fibonacci$3 = bench("fibonacci", (function (param) {
        var go = function (_a, _b, _n) {
          while(true) {
            var n = _n;
            var b = _b;
            var a = _a;
            if (n === 0) {
              return a;
            }
            _n = n - 1 | 0;
            _b = parens$3(a);
            _a = parens$3((function(a,b){
                return function (param) {
                  return Curry._1(a, Curry._1(b, param));
                }
                }(a,b)));
            continue ;
          };
        };
        var ss = go((function (param) {
                return {
                        hd: "1",
                        tl: param
                      };
              }), (function (param) {
                return {
                        hd: "0",
                        tl: param
                      };
              }), 32);
        return to_string$1(Curry._1(ss, /* [] */0));
      }));

var T$2 = {
  popen: popen$3,
  pclose: pclose$3,
  parens: parens$3,
  parens_in: parens_in$3,
  fibonacci: fibonacci$3
};

if (!Caml_obj.caml_equal(parens_in$3, parens_in)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          184,
          4
        ],
        Error: new Error()
      };
}

if (!(fibonacci$3 === undefined || Caml_obj.caml_equal(fibonacci$3, fibonacci))) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          185,
          4
        ],
        Error: new Error()
      };
}

var Test_dlist = {
  T: T$2
};

Printf.printf(/* Format */{
      _0: {
        TAG: /* Char_literal */12,
        _0: /* '\n' */10,
        _1: {
          TAG: /* Flush */10,
          _0: /* End_of_format */0
        }
      },
      _1: "\n%!"
    });

header("Custom tree");

var popen$4 = {
  TAG: /* Single */0,
  _0: " begin "
};

var pclose$4 = {
  TAG: /* Single */0,
  _0: " end "
};

function parens$4(x) {
  return $at$4(popen$4, $at$4(x, pclose$4));
}

var parens_in$4 = bench("parens", (function (param) {
        var go = function (_acc, _n) {
          while(true) {
            var n = _n;
            var acc = _acc;
            if (n === 0) {
              return acc;
            }
            _n = n - 1 | 0;
            _acc = parens$4(acc);
            continue ;
          };
        };
        return to_string$3(go(/* Empty */0, 20000));
      }));

var fibonacci$4 = bench("fibonacci", (function (param) {
        var go = function (_a, _b, _n) {
          while(true) {
            var n = _n;
            var b = _b;
            var a = _a;
            if (n === 0) {
              return a;
            }
            _n = n - 1 | 0;
            _b = parens$4(a);
            _a = parens$4($at$4(a, b));
            continue ;
          };
        };
        return to_string$3(go({
                        TAG: /* Single */0,
                        _0: "1"
                      }, {
                        TAG: /* Single */0,
                        _0: "0"
                      }, 32));
      }));

var T$3 = {
  popen: popen$4,
  pclose: pclose$4,
  parens: parens$4,
  parens_in: parens_in$4,
  fibonacci: fibonacci$4
};

if (!Caml_obj.caml_equal(parens_in$4, parens_in)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          184,
          4
        ],
        Error: new Error()
      };
}

if (!(fibonacci$4 === undefined || Caml_obj.caml_equal(fibonacci$4, fibonacci))) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          185,
          4
        ],
        Error: new Error()
      };
}

var Test_tree = {
  T: T$3
};

Printf.printf(/* Format */{
      _0: {
        TAG: /* Char_literal */12,
        _0: /* '\n' */10,
        _1: {
          TAG: /* Flush */10,
          _0: /* End_of_format */0
        }
      },
      _1: "\n%!"
    });

header("Deque");

var popen$5 = Deque.cons(" begin ", Deque.empty);

var pclose$5 = Deque.cons(" end ", Deque.empty);

function parens$5(x) {
  return Deque.append(popen$5, Deque.append(x, pclose$5));
}

var parens_in$5 = bench("parens", (function (param) {
        var go = function (_acc, _n) {
          while(true) {
            var n = _n;
            var acc = _acc;
            if (n === 0) {
              return acc;
            }
            _n = n - 1 | 0;
            _acc = parens$5(acc);
            continue ;
          };
        };
        return to_string$4(go(Deque.empty, 20000));
      }));

var fibonacci$5 = bench("fibonacci", (function (param) {
        var go = function (_a, _b, _n) {
          while(true) {
            var n = _n;
            var b = _b;
            var a = _a;
            if (n === 0) {
              return a;
            }
            _n = n - 1 | 0;
            _b = parens$5(a);
            _a = parens$5(Deque.append(a, b));
            continue ;
          };
        };
        return to_string$4(go(Deque.cons("1", Deque.empty), Deque.cons("0", Deque.empty), 32));
      }));

var T$4 = {
  popen: popen$5,
  pclose: pclose$5,
  parens: parens$5,
  parens_in: parens_in$5,
  fibonacci: fibonacci$5
};

if (!Caml_obj.caml_equal(parens_in$5, parens_in)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          184,
          4
        ],
        Error: new Error()
      };
}

if (!(fibonacci$5 === undefined || Caml_obj.caml_equal(fibonacci$5, fibonacci))) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          185,
          4
        ],
        Error: new Error()
      };
}

var Test_deque = {
  T: T$4
};

Printf.printf(/* Format */{
      _0: {
        TAG: /* Char_literal */12,
        _0: /* '\n' */10,
        _1: {
          TAG: /* Flush */10,
          _0: /* End_of_format */0
        }
      },
      _1: "\n%!"
    });

header("Steque");

var popen$6 = of_string$5(" begin ");

var pclose$6 = of_string$5(" end ");

function parens$6(x) {
  var b = Deque.Steque.append(x, pclose$6);
  return Deque.Steque.append(popen$6, b);
}

var parens_in$6 = bench("parens", (function (param) {
        var go = function (_acc, _n) {
          while(true) {
            var n = _n;
            var acc = _acc;
            if (n === 0) {
              return acc;
            }
            _n = n - 1 | 0;
            _acc = parens$6(acc);
            continue ;
          };
        };
        return to_string$5(go(empty$2, 20000));
      }));

var fibonacci$6 = bench("fibonacci", (function (param) {
        var go = function (_a, _b, _n) {
          while(true) {
            var n = _n;
            var b = _b;
            var a = _a;
            if (n === 0) {
              return a;
            }
            _n = n - 1 | 0;
            _b = parens$6(a);
            _a = parens$6(Deque.Steque.append(a, b));
            continue ;
          };
        };
        return to_string$5(go(of_string$5("1"), of_string$5("0"), 32));
      }));

var T$5 = {
  popen: popen$6,
  pclose: pclose$6,
  parens: parens$6,
  parens_in: parens_in$6,
  fibonacci: fibonacci$6
};

if (!Caml_obj.caml_equal(parens_in$6, parens_in)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          184,
          4
        ],
        Error: new Error()
      };
}

if (!(fibonacci$6 === undefined || Caml_obj.caml_equal(fibonacci$6, fibonacci))) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          185,
          4
        ],
        Error: new Error()
      };
}

var Test_steque = {
  T: T$5
};

Printf.printf(/* Format */{
      _0: {
        TAG: /* Char_literal */12,
        _0: /* '\n' */10,
        _1: {
          TAG: /* Flush */10,
          _0: /* End_of_format */0
        }
      },
      _1: "\n%!"
    });

header("Buffer");

var popen$7 = " begin ";

var pclose$7 = " end ";

var parens_in$7 = bench("parens", (function (param) {
        var buf = $$Buffer.create(0);
        var go = function (n) {
          if (n === 0) {
            return ;
          } else {
            $$Buffer.add_string(buf, popen$7);
            go(n - 1 | 0);
            return $$Buffer.add_string(buf, pclose$7);
          }
        };
        go(20000);
        return $$Buffer.contents(buf);
      }));

var fibonacci$7 = bench("fibonacci", (function (param) {
        var buf = $$Buffer.create(0);
        var go = function (n) {
          if (n !== 0) {
            if (n !== 1) {
              $$Buffer.add_string(buf, popen$7);
              go(n - 1 | 0);
              if (n > 2) {
                $$Buffer.add_string(buf, popen$7);
              }
              go(n - 2 | 0);
              if (n > 2) {
                $$Buffer.add_string(buf, pclose$7);
              }
              return $$Buffer.add_string(buf, pclose$7);
            } else {
              return $$Buffer.add_string(buf, "1");
            }
          } else {
            return $$Buffer.add_string(buf, "0");
          }
        };
        go(33);
        return $$Buffer.contents(buf);
      }));

if (!Caml_obj.caml_equal(parens_in$7, parens_in)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          269,
          4
        ],
        Error: new Error()
      };
}

if (!Caml_obj.caml_equal(fibonacci$7, fibonacci)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string_builder.re",
          270,
          4
        ],
        Error: new Error()
      };
}

var Test_buffer = {
  popen: popen$7,
  pclose: pclose$7,
  parens_in: parens_in$7,
  fibonacci: fibonacci$7
};

export {
  Build_string ,
  Fold_to_string ,
  Build_list ,
  Build_list_safe ,
  Build_dlist ,
  Build_tree ,
  Build_deque ,
  Build_steque ,
  bench ,
  Test ,
  header ,
  Test_string ,
  Test_check ,
  Test_list ,
  Test_list_safe ,
  Test_dlist ,
  Test_tree ,
  Test_deque ,
  Test_steque ,
  Test_buffer ,
  
}
/*  Not a pure module */
