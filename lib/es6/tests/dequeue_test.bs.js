// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "../src/List.bs.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Deque from "../src/deque.bs.js";
import * as Random from "bs-platform/lib/es6/random.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";

function cons(x, t) {
  return {
          hd: x,
          tl: t
        };
}

function uncons(param) {
  if (param) {
    return [
            param.hd,
            param.tl
          ];
  }
  
}

function unsnoc(t) {
  var _acc = /* [] */0;
  var _param = t;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return ;
    }
    var t$1 = param.tl;
    var x = param.hd;
    if (!t$1) {
      return [
              List.rev(acc),
              x
            ];
    }
    _param = t$1;
    _acc = {
      hd: x,
      tl: acc
    };
    continue ;
  };
}

function concat(a, b) {
  return List.rev_append(List.rev(a), b);
}

function snoc(t, x) {
  return List.rev_append(List.rev(t), {
              hd: x,
              tl: /* [] */0
            });
}

function to_list(t) {
  return t;
}

var Naive = {
  empty: /* [] */0,
  cons: cons,
  uncons: uncons,
  unsnoc: unsnoc,
  concat: concat,
  snoc: snoc,
  rev: List.rev,
  to_list: to_list,
  length: List.length,
  nth: List.nth
};

function Bi(A, B) {
  var uncons_to_list = function (t) {
    var match = Curry._1(B.uncons, t);
    if (match !== undefined) {
      return {
              hd: match[0],
              tl: uncons_to_list(match[1])
            };
    } else {
      return /* [] */0;
    }
  };
  var unsnoc_to_list = function (_acc, _t) {
    while(true) {
      var t = _t;
      var acc = _acc;
      var match = Curry._1(B.unsnoc, t);
      if (match === undefined) {
        return acc;
      }
      _t = match[0];
      _acc = {
        hd: match[1],
        tl: acc
      };
      continue ;
    };
  };
  var unsnoc_to_list$1 = function (t) {
    return unsnoc_to_list(/* [] */0, t);
  };
  var make = function (a, b) {
    var xs = Curry._1(A.to_list, a);
    var ys = Curry._1(B.to_list, b);
    if (!Caml_obj.caml_equal(xs, ys)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              63,
              4
            ],
            Error: new Error()
          };
    }
    if (!Caml_obj.caml_equal(xs, uncons_to_list(b))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              64,
              4
            ],
            Error: new Error()
          };
    }
    if (!Caml_obj.caml_equal(xs, unsnoc_to_list(/* [] */0, b))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              65,
              4
            ],
            Error: new Error()
          };
    }
    if (List.length(xs) !== Curry._1(B.length, b)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              66,
              4
            ],
            Error: new Error()
          };
    }
    return [
            a,
            b
          ];
  };
  var empty = make(A.empty, B.empty);
  var cons = function (x, param) {
    return make(Curry._2(A.cons, x, param[0]), Curry._2(B.cons, x, param[1]));
  };
  var snoc = function (param, x) {
    return make(Curry._2(A.snoc, param[0], x), Curry._2(B.snoc, param[1], x));
  };
  var uncons = function (param) {
    var match = Curry._1(A.uncons, param[0]);
    var match$1 = Curry._1(B.uncons, param[1]);
    if (match !== undefined) {
      if (match$1 !== undefined) {
        var x = match[0];
        if (!Caml_obj.caml_equal(x, match$1[0])) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "dequeue_test.re",
                  80,
                  6
                ],
                Error: new Error()
              };
        }
        return [
                x,
                make(match[1], match$1[1])
              ];
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              82,
              11
            ],
            Error: new Error()
          };
    }
    if (match$1 === undefined) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            82,
            11
          ],
          Error: new Error()
        };
  };
  var unsnoc = function (param) {
    var match = Curry._1(A.unsnoc, param[0]);
    var match$1 = Curry._1(B.unsnoc, param[1]);
    if (match !== undefined) {
      if (match$1 !== undefined) {
        var x = match[1];
        if (!Caml_obj.caml_equal(x, match$1[1])) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "dequeue_test.re",
                  89,
                  6
                ],
                Error: new Error()
              };
        }
        return [
                make(match[0], match$1[0]),
                x
              ];
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              91,
              11
            ],
            Error: new Error()
          };
    }
    if (match$1 === undefined) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            91,
            11
          ],
          Error: new Error()
        };
  };
  var rev = function (param) {
    return make(Curry._1(A.rev, param[0]), Curry._1(B.rev, param[1]));
  };
  var check_nth = function (param) {
    var b = param[1];
    var a = param[0];
    var n = Curry._1(B.length, b);
    if (n !== Curry._1(A.length, a)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              98,
              4
            ],
            Error: new Error()
          };
    }
    if (n === 0) {
      return ;
    }
    var i = Random.$$int(n);
    var x = Curry._2(A.nth, a, i);
    var y = Curry._2(B.nth, b, i);
    if (Caml_obj.caml_equal(x, y)) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            105,
            6
          ],
          Error: new Error()
        };
  };
  return {
          uncons_to_list: uncons_to_list,
          unsnoc_to_list: unsnoc_to_list$1,
          make: make,
          empty: empty,
          cons: cons,
          snoc: snoc,
          uncons: uncons,
          unsnoc: unsnoc,
          rev: rev,
          check_nth: check_nth
        };
}

function Test(X) {
  var uncons_to_list = function (t) {
    var match = Curry._1(X.uncons, t);
    if (match !== undefined) {
      return {
              hd: match[0],
              tl: uncons_to_list(match[1])
            };
    } else {
      return /* [] */0;
    }
  };
  var unsnoc_to_list = function (_acc, _t) {
    while(true) {
      var t = _t;
      var acc = _acc;
      var match = Curry._1(X.unsnoc, t);
      if (match === undefined) {
        return acc;
      }
      _t = match[0];
      _acc = {
        hd: match[1],
        tl: acc
      };
      continue ;
    };
  };
  var unsnoc_to_list$1 = function (t) {
    return unsnoc_to_list(/* [] */0, t);
  };
  var make = function (a, b) {
    var xs = to_list(a);
    var ys = Curry._1(X.to_list, b);
    if (!Caml_obj.caml_equal(xs, ys)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              63,
              4
            ],
            Error: new Error()
          };
    }
    if (!Caml_obj.caml_equal(xs, uncons_to_list(b))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              64,
              4
            ],
            Error: new Error()
          };
    }
    if (!Caml_obj.caml_equal(xs, unsnoc_to_list(/* [] */0, b))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              65,
              4
            ],
            Error: new Error()
          };
    }
    if (List.length(xs) !== Curry._1(X.length, b)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              66,
              4
            ],
            Error: new Error()
          };
    }
    return [
            a,
            b
          ];
  };
  var empty = make(/* [] */0, X.empty);
  var cons$1 = function (x, param) {
    return make(cons(x, param[0]), Curry._2(X.cons, x, param[1]));
  };
  var snoc$1 = function (param, x) {
    return make(snoc(param[0], x), Curry._2(X.snoc, param[1], x));
  };
  var uncons$1 = function (param) {
    var match = uncons(param[0]);
    var match$1 = Curry._1(X.uncons, param[1]);
    if (match !== undefined) {
      if (match$1 !== undefined) {
        var x = match[0];
        if (!Caml_obj.caml_equal(x, match$1[0])) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "dequeue_test.re",
                  80,
                  6
                ],
                Error: new Error()
              };
        }
        return [
                x,
                make(match[1], match$1[1])
              ];
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              82,
              11
            ],
            Error: new Error()
          };
    }
    if (match$1 === undefined) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            82,
            11
          ],
          Error: new Error()
        };
  };
  var unsnoc$1 = function (param) {
    var match = unsnoc(param[0]);
    var match$1 = Curry._1(X.unsnoc, param[1]);
    if (match !== undefined) {
      if (match$1 !== undefined) {
        var x = match[1];
        if (!Caml_obj.caml_equal(x, match$1[1])) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "dequeue_test.re",
                  89,
                  6
                ],
                Error: new Error()
              };
        }
        return [
                make(match[0], match$1[0]),
                x
              ];
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              91,
              11
            ],
            Error: new Error()
          };
    }
    if (match$1 === undefined) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            91,
            11
          ],
          Error: new Error()
        };
  };
  var rev = function (param) {
    return make(List.rev(param[0]), Curry._1(X.rev, param[1]));
  };
  var check_nth = function (param) {
    var b = param[1];
    var a = param[0];
    var n = Curry._1(X.length, b);
    if (n !== List.length(a)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              98,
              4
            ],
            Error: new Error()
          };
    }
    if (n === 0) {
      return ;
    }
    var i = Random.$$int(n);
    var x = List.nth(a, i);
    var y = Curry._2(X.nth, b, i);
    if (Caml_obj.caml_equal(x, y)) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            105,
            6
          ],
          Error: new Error()
        };
  };
  var D2 = {
    uncons_to_list: uncons_to_list,
    unsnoc_to_list: unsnoc_to_list$1,
    make: make,
    empty: empty,
    cons: cons$1,
    snoc: snoc$1,
    uncons: uncons$1,
    unsnoc: unsnoc$1,
    rev: rev,
    check_nth: check_nth
  };
  var elt = function (param) {
    return Random.$$int(10000);
  };
  var some_fst = function (t, param) {
    if (param !== undefined) {
      return param[0];
    } else {
      return t;
    }
  };
  var some_snd = function (t, param) {
    if (param !== undefined) {
      return param[1];
    } else {
      return t;
    }
  };
  var test = function (t) {
    var match = Random.$$int(6);
    switch (match) {
      case 0 :
          return Curry._2(cons$1, Random.$$int(10000), t);
      case 1 :
          return Curry._2(snoc$1, t, Random.$$int(10000));
      case 2 :
          return some_snd(t, Curry._1(uncons$1, t));
      case 3 :
          return some_fst(t, Curry._1(unsnoc$1, t));
      case 4 :
          return Curry._1(rev, t);
      case 5 :
          Curry._1(check_nth, t);
          return t;
      default:
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "dequeue_test.re",
                135,
                11
              ],
              Error: new Error()
            };
    }
  };
  var test_repeatedly = function (_n, _t) {
    while(true) {
      var t = _t;
      var n = _n;
      if (n <= 0) {
        return ;
      }
      _t = test(t);
      _n = n - 1 | 0;
      continue ;
    };
  };
  test_repeatedly(100000, empty);
  return {
          D2: D2,
          elt: elt,
          some_fst: some_fst,
          some_snd: some_snd,
          test: test,
          test_repeatedly: test_repeatedly
        };
}

function uncons_to_list(t) {
  var match = Curry._1(Deque.Dequeue.uncons, t);
  if (match !== undefined) {
    return {
            hd: match[0],
            tl: uncons_to_list(match[1])
          };
  } else {
    return /* [] */0;
  }
}

function unsnoc_to_list(_acc, _t) {
  while(true) {
    var t = _t;
    var acc = _acc;
    var match = Curry._1(Deque.Dequeue.unsnoc, t);
    if (match === undefined) {
      return acc;
    }
    _t = match[0];
    _acc = {
      hd: match[1],
      tl: acc
    };
    continue ;
  };
}

function unsnoc_to_list$1(t) {
  return unsnoc_to_list(/* [] */0, t);
}

function make(a, b) {
  var xs = to_list(a);
  var ys = Curry._1(Deque.Dequeue.to_list, b);
  if (!Caml_obj.caml_equal(xs, ys)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            63,
            4
          ],
          Error: new Error()
        };
  }
  if (!Caml_obj.caml_equal(xs, uncons_to_list(b))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            64,
            4
          ],
          Error: new Error()
        };
  }
  if (!Caml_obj.caml_equal(xs, unsnoc_to_list(/* [] */0, b))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            65,
            4
          ],
          Error: new Error()
        };
  }
  if (List.length(xs) !== Curry._1(Deque.Dequeue.length, b)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            66,
            4
          ],
          Error: new Error()
        };
  }
  return [
          a,
          b
        ];
}

var empty = make(/* [] */0, Deque.Dequeue.empty);

function cons$1(x, param) {
  return make(cons(x, param[0]), Curry._2(Deque.Dequeue.cons, x, param[1]));
}

function snoc$1(param, x) {
  return make(snoc(param[0], x), Curry._2(Deque.Dequeue.snoc, param[1], x));
}

function uncons$1(param) {
  var match = uncons(param[0]);
  var match$1 = Curry._1(Deque.Dequeue.uncons, param[1]);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      var x = match[0];
      if (!Caml_obj.caml_equal(x, match$1[0])) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "dequeue_test.re",
                80,
                6
              ],
              Error: new Error()
            };
      }
      return [
              x,
              make(match[1], match$1[1])
            ];
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            82,
            11
          ],
          Error: new Error()
        };
  }
  if (match$1 === undefined) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          82,
          11
        ],
        Error: new Error()
      };
}

function unsnoc$1(param) {
  var match = unsnoc(param[0]);
  var match$1 = Curry._1(Deque.Dequeue.unsnoc, param[1]);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      var x = match[1];
      if (!Caml_obj.caml_equal(x, match$1[1])) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "dequeue_test.re",
                89,
                6
              ],
              Error: new Error()
            };
      }
      return [
              make(match[0], match$1[0]),
              x
            ];
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            91,
            11
          ],
          Error: new Error()
        };
  }
  if (match$1 === undefined) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          91,
          11
        ],
        Error: new Error()
      };
}

function rev(param) {
  return make(List.rev(param[0]), Curry._1(Deque.Dequeue.rev, param[1]));
}

function check_nth(param) {
  var b = param[1];
  var a = param[0];
  var n = Curry._1(Deque.Dequeue.length, b);
  if (n !== List.length(a)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            98,
            4
          ],
          Error: new Error()
        };
  }
  if (n === 0) {
    return ;
  }
  var i = Random.$$int(n);
  var x = List.nth(a, i);
  var y = Curry._2(Deque.Dequeue.nth, b, i);
  if (Caml_obj.caml_equal(x, y)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          105,
          6
        ],
        Error: new Error()
      };
}

var D2 = {
  uncons_to_list: uncons_to_list,
  unsnoc_to_list: unsnoc_to_list$1,
  make: make,
  empty: empty,
  cons: cons$1,
  snoc: snoc$1,
  uncons: uncons$1,
  unsnoc: unsnoc$1,
  rev: rev,
  check_nth: check_nth
};

function elt(param) {
  return Random.$$int(10000);
}

function some_fst(t, param) {
  if (param !== undefined) {
    return param[0];
  } else {
    return t;
  }
}

function some_snd(t, param) {
  if (param !== undefined) {
    return param[1];
  } else {
    return t;
  }
}

function test(t) {
  var match = Random.$$int(6);
  switch (match) {
    case 0 :
        return Curry._2(cons$1, Random.$$int(10000), t);
    case 1 :
        return Curry._2(snoc$1, t, Random.$$int(10000));
    case 2 :
        return some_snd(t, Curry._1(uncons$1, t));
    case 3 :
        return some_fst(t, Curry._1(unsnoc$1, t));
    case 4 :
        return Curry._1(rev, t);
    case 5 :
        Curry._1(check_nth, t);
        return t;
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              135,
              11
            ],
            Error: new Error()
          };
  }
}

function test_repeatedly(_n, _t) {
  while(true) {
    var t = _t;
    var n = _n;
    if (n <= 0) {
      return ;
    }
    _t = test(t);
    _n = n - 1 | 0;
    continue ;
  };
}

test_repeatedly(100000, empty);

var A = {
  D2: D2,
  elt: elt,
  some_fst: some_fst,
  some_snd: some_snd,
  test: test,
  test_repeatedly: test_repeatedly
};

function uncons_to_list$1(t) {
  var match = Curry._1(Deque.Deck.uncons, t);
  if (match !== undefined) {
    return {
            hd: match[0],
            tl: uncons_to_list$1(match[1])
          };
  } else {
    return /* [] */0;
  }
}

function unsnoc_to_list$2(_acc, _t) {
  while(true) {
    var t = _t;
    var acc = _acc;
    var match = Curry._1(Deque.Deck.unsnoc, t);
    if (match === undefined) {
      return acc;
    }
    _t = match[0];
    _acc = {
      hd: match[1],
      tl: acc
    };
    continue ;
  };
}

function unsnoc_to_list$3(t) {
  return unsnoc_to_list$2(/* [] */0, t);
}

function make$1(a, b) {
  var xs = to_list(a);
  var ys = Curry._1(Deque.Deck.to_list, b);
  if (!Caml_obj.caml_equal(xs, ys)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            63,
            4
          ],
          Error: new Error()
        };
  }
  if (!Caml_obj.caml_equal(xs, uncons_to_list$1(b))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            64,
            4
          ],
          Error: new Error()
        };
  }
  if (!Caml_obj.caml_equal(xs, unsnoc_to_list$2(/* [] */0, b))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            65,
            4
          ],
          Error: new Error()
        };
  }
  if (List.length(xs) !== Curry._1(Deque.Deck.length, b)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            66,
            4
          ],
          Error: new Error()
        };
  }
  return [
          a,
          b
        ];
}

var empty$1 = make$1(/* [] */0, Deque.Deck.empty);

function cons$2(x, param) {
  return make$1(cons(x, param[0]), Curry._2(Deque.Deck.cons, x, param[1]));
}

function snoc$2(param, x) {
  return make$1(snoc(param[0], x), Curry._2(Deque.Deck.snoc, param[1], x));
}

function uncons$2(param) {
  var match = uncons(param[0]);
  var match$1 = Curry._1(Deque.Deck.uncons, param[1]);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      var x = match[0];
      if (!Caml_obj.caml_equal(x, match$1[0])) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "dequeue_test.re",
                80,
                6
              ],
              Error: new Error()
            };
      }
      return [
              x,
              make$1(match[1], match$1[1])
            ];
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            82,
            11
          ],
          Error: new Error()
        };
  }
  if (match$1 === undefined) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          82,
          11
        ],
        Error: new Error()
      };
}

function unsnoc$2(param) {
  var match = unsnoc(param[0]);
  var match$1 = Curry._1(Deque.Deck.unsnoc, param[1]);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      var x = match[1];
      if (!Caml_obj.caml_equal(x, match$1[1])) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "dequeue_test.re",
                89,
                6
              ],
              Error: new Error()
            };
      }
      return [
              make$1(match[0], match$1[0]),
              x
            ];
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            91,
            11
          ],
          Error: new Error()
        };
  }
  if (match$1 === undefined) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          91,
          11
        ],
        Error: new Error()
      };
}

function rev$1(param) {
  return make$1(List.rev(param[0]), Curry._1(Deque.Deck.rev, param[1]));
}

function check_nth$1(param) {
  var b = param[1];
  var a = param[0];
  var n = Curry._1(Deque.Deck.length, b);
  if (n !== List.length(a)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            98,
            4
          ],
          Error: new Error()
        };
  }
  if (n === 0) {
    return ;
  }
  var i = Random.$$int(n);
  var x = List.nth(a, i);
  var y = Curry._2(Deque.Deck.nth, b, i);
  if (Caml_obj.caml_equal(x, y)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          105,
          6
        ],
        Error: new Error()
      };
}

var D2$1 = {
  uncons_to_list: uncons_to_list$1,
  unsnoc_to_list: unsnoc_to_list$3,
  make: make$1,
  empty: empty$1,
  cons: cons$2,
  snoc: snoc$2,
  uncons: uncons$2,
  unsnoc: unsnoc$2,
  rev: rev$1,
  check_nth: check_nth$1
};

function elt$1(param) {
  return Random.$$int(10000);
}

function some_fst$1(t, param) {
  if (param !== undefined) {
    return param[0];
  } else {
    return t;
  }
}

function some_snd$1(t, param) {
  if (param !== undefined) {
    return param[1];
  } else {
    return t;
  }
}

function test$1(t) {
  var match = Random.$$int(6);
  switch (match) {
    case 0 :
        return Curry._2(cons$2, Random.$$int(10000), t);
    case 1 :
        return Curry._2(snoc$2, t, Random.$$int(10000));
    case 2 :
        return some_snd$1(t, Curry._1(uncons$2, t));
    case 3 :
        return some_fst$1(t, Curry._1(unsnoc$2, t));
    case 4 :
        return Curry._1(rev$1, t);
    case 5 :
        Curry._1(check_nth$1, t);
        return t;
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              135,
              11
            ],
            Error: new Error()
          };
  }
}

function test_repeatedly$1(_n, _t) {
  while(true) {
    var t = _t;
    var n = _n;
    if (n <= 0) {
      return ;
    }
    _t = test$1(t);
    _n = n - 1 | 0;
    continue ;
  };
}

test_repeatedly$1(100000, empty$1);

var B = {
  D2: D2$1,
  elt: elt$1,
  some_fst: some_fst$1,
  some_snd: some_snd$1,
  test: test$1,
  test_repeatedly: test_repeatedly$1
};

function uncons_to_list$2(t) {
  var match = Curry._1(Deque.Deckrev.uncons, t);
  if (match !== undefined) {
    return {
            hd: match[0],
            tl: uncons_to_list$2(match[1])
          };
  } else {
    return /* [] */0;
  }
}

function unsnoc_to_list$4(_acc, _t) {
  while(true) {
    var t = _t;
    var acc = _acc;
    var match = Curry._1(Deque.Deckrev.unsnoc, t);
    if (match === undefined) {
      return acc;
    }
    _t = match[0];
    _acc = {
      hd: match[1],
      tl: acc
    };
    continue ;
  };
}

function unsnoc_to_list$5(t) {
  return unsnoc_to_list$4(/* [] */0, t);
}

function make$2(a, b) {
  var xs = to_list(a);
  var ys = Curry._1(Deque.Deckrev.to_list, b);
  if (!Caml_obj.caml_equal(xs, ys)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            63,
            4
          ],
          Error: new Error()
        };
  }
  if (!Caml_obj.caml_equal(xs, uncons_to_list$2(b))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            64,
            4
          ],
          Error: new Error()
        };
  }
  if (!Caml_obj.caml_equal(xs, unsnoc_to_list$4(/* [] */0, b))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            65,
            4
          ],
          Error: new Error()
        };
  }
  if (List.length(xs) !== Curry._1(Deque.Deckrev.length, b)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            66,
            4
          ],
          Error: new Error()
        };
  }
  return [
          a,
          b
        ];
}

var empty$2 = make$2(/* [] */0, Deque.Deckrev.empty);

function cons$3(x, param) {
  return make$2(cons(x, param[0]), Curry._2(Deque.Deckrev.cons, x, param[1]));
}

function snoc$3(param, x) {
  return make$2(snoc(param[0], x), Curry._2(Deque.Deckrev.snoc, param[1], x));
}

function uncons$3(param) {
  var match = uncons(param[0]);
  var match$1 = Curry._1(Deque.Deckrev.uncons, param[1]);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      var x = match[0];
      if (!Caml_obj.caml_equal(x, match$1[0])) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "dequeue_test.re",
                80,
                6
              ],
              Error: new Error()
            };
      }
      return [
              x,
              make$2(match[1], match$1[1])
            ];
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            82,
            11
          ],
          Error: new Error()
        };
  }
  if (match$1 === undefined) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          82,
          11
        ],
        Error: new Error()
      };
}

function unsnoc$3(param) {
  var match = unsnoc(param[0]);
  var match$1 = Curry._1(Deque.Deckrev.unsnoc, param[1]);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      var x = match[1];
      if (!Caml_obj.caml_equal(x, match$1[1])) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "dequeue_test.re",
                89,
                6
              ],
              Error: new Error()
            };
      }
      return [
              make$2(match[0], match$1[0]),
              x
            ];
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            91,
            11
          ],
          Error: new Error()
        };
  }
  if (match$1 === undefined) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          91,
          11
        ],
        Error: new Error()
      };
}

function rev$2(param) {
  return make$2(List.rev(param[0]), Curry._1(Deque.Deckrev.rev, param[1]));
}

function check_nth$2(param) {
  var b = param[1];
  var a = param[0];
  var n = Curry._1(Deque.Deckrev.length, b);
  if (n !== List.length(a)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "dequeue_test.re",
            98,
            4
          ],
          Error: new Error()
        };
  }
  if (n === 0) {
    return ;
  }
  var i = Random.$$int(n);
  var x = List.nth(a, i);
  var y = Curry._2(Deque.Deckrev.nth, b, i);
  if (Caml_obj.caml_equal(x, y)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "dequeue_test.re",
          105,
          6
        ],
        Error: new Error()
      };
}

var D2$2 = {
  uncons_to_list: uncons_to_list$2,
  unsnoc_to_list: unsnoc_to_list$5,
  make: make$2,
  empty: empty$2,
  cons: cons$3,
  snoc: snoc$3,
  uncons: uncons$3,
  unsnoc: unsnoc$3,
  rev: rev$2,
  check_nth: check_nth$2
};

function elt$2(param) {
  return Random.$$int(10000);
}

function some_fst$2(t, param) {
  if (param !== undefined) {
    return param[0];
  } else {
    return t;
  }
}

function some_snd$2(t, param) {
  if (param !== undefined) {
    return param[1];
  } else {
    return t;
  }
}

function test$2(t) {
  var match = Random.$$int(6);
  switch (match) {
    case 0 :
        return Curry._2(cons$3, Random.$$int(10000), t);
    case 1 :
        return Curry._2(snoc$3, t, Random.$$int(10000));
    case 2 :
        return some_snd$2(t, Curry._1(uncons$3, t));
    case 3 :
        return some_fst$2(t, Curry._1(unsnoc$3, t));
    case 4 :
        return Curry._1(rev$2, t);
    case 5 :
        Curry._1(check_nth$2, t);
        return t;
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue_test.re",
              135,
              11
            ],
            Error: new Error()
          };
  }
}

function test_repeatedly$2(_n, _t) {
  while(true) {
    var t = _t;
    var n = _n;
    if (n <= 0) {
      return ;
    }
    _t = test$2(t);
    _n = n - 1 | 0;
    continue ;
  };
}

test_repeatedly$2(100000, empty$2);

var C = {
  D2: D2$2,
  elt: elt$2,
  some_fst: some_fst$2,
  some_snd: some_snd$2,
  test: test$2,
  test_repeatedly: test_repeatedly$2
};

export {
  Naive ,
  Bi ,
  Test ,
  A ,
  B ,
  C ,
  
}
/* empty Not a pure module */
