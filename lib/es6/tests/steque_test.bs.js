// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "../src/List.bs.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Deque from "../src/deque.bs.js";
import * as Random from "bs-platform/lib/es6/random.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";

function Bi(A, B) {
  var compare_prefix = function (_n, _param) {
    while(true) {
      var param = _param;
      var n = _n;
      var b = param[1];
      var a = param[0];
      if (n <= 0) {
        return [
                a,
                b
              ];
      }
      var match = Curry._1(A.uncons, a);
      var match$1 = Curry._1(B.uncons, b);
      if (match !== undefined) {
        if (match$1 !== undefined) {
          if (!Caml_obj.caml_equal(match[0], match$1[0])) {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "steque_test.re",
                    21,
                    8
                  ],
                  Error: new Error()
                };
          }
          _param = [
            match[1],
            match$1[1]
          ];
          _n = n - 1 | 0;
          continue ;
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "steque_test.re",
                23,
                13
              ],
              Error: new Error()
            };
      }
      if (match$1 !== undefined) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "steque_test.re",
                23,
                13
              ],
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    };
  };
  var make = function (a, b) {
    try {
      return compare_prefix(500, [
                  a,
                  b
                ]);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return [
                a,
                b
              ];
      }
      throw exn;
    }
  };
  var empty = make(A.empty, B.empty);
  var cons = function (x, param) {
    return make(Curry._2(A.cons, x, param[0]), Curry._2(B.cons, x, param[1]));
  };
  var snoc = function (param, x) {
    return make(Curry._2(A.snoc, param[0], x), Curry._2(B.snoc, param[1], x));
  };
  var uncons = function (param) {
    var match = Curry._1(A.uncons, param[0]);
    var match$1 = Curry._1(B.uncons, param[1]);
    if (match !== undefined) {
      if (match$1 !== undefined) {
        var x = match[0];
        if (!Caml_obj.caml_equal(x, match$1[0])) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "steque_test.re",
                  42,
                  6
                ],
                Error: new Error()
              };
        }
        return [
                x,
                make(match[1], match$1[1])
              ];
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "steque_test.re",
              44,
              11
            ],
            Error: new Error()
          };
    }
    if (match$1 === undefined) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "steque_test.re",
            44,
            11
          ],
          Error: new Error()
        };
  };
  var append = function (param, param$1) {
    return make(Curry._2(A.append, param[0], param$1[0]), Curry._2(B.append, param[1], param$1[1]));
  };
  var length = function (param) {
    return Curry._1(A.length, param[0]);
  };
  return {
          compare_prefix: compare_prefix,
          make: make,
          empty: empty,
          cons: cons,
          snoc: snoc,
          uncons: uncons,
          append: append,
          length: length
        };
}

var partial_arg_empty = Deque.Steque.empty;

var partial_arg_cons = Deque.Steque.cons;

var partial_arg_snoc = Deque.Steque.snoc;

var partial_arg_uncons = Deque.Steque.uncons;

var partial_arg_append = Deque.Steque.append;

var partial_arg_length = Deque.Steque.length;

var B_empty = Deque.Deck.empty;

var B_cons = Deque.Deck.cons;

var B_snoc = Deque.Deck.snoc;

var B_uncons = Deque.Deck.uncons;

var B_append = Deque.Deck.append;

function compare_prefix(_n, _param) {
  while(true) {
    var param = _param;
    var n = _n;
    var b = param[1];
    var a = param[0];
    if (n <= 0) {
      return [
              a,
              b
            ];
    }
    var match = Curry._1(partial_arg_uncons, a);
    var match$1 = Curry._1(B_uncons, b);
    if (match !== undefined) {
      if (match$1 !== undefined) {
        if (!Caml_obj.caml_equal(match[0], match$1[0])) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "steque_test.re",
                  21,
                  8
                ],
                Error: new Error()
              };
        }
        _param = [
          match[1],
          match$1[1]
        ];
        _n = n - 1 | 0;
        continue ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "steque_test.re",
              23,
              13
            ],
            Error: new Error()
          };
    }
    if (match$1 !== undefined) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "steque_test.re",
              23,
              13
            ],
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function make(a, b) {
  try {
    return compare_prefix(500, [
                a,
                b
              ]);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return [
              a,
              b
            ];
    }
    throw exn;
  }
}

var empty = make(partial_arg_empty, B_empty);

function cons(x, param) {
  return make(Curry._2(partial_arg_cons, x, param[0]), Curry._2(B_cons, x, param[1]));
}

function snoc(param, x) {
  return make(Curry._2(partial_arg_snoc, param[0], x), Curry._2(B_snoc, param[1], x));
}

function uncons(param) {
  var match = Curry._1(partial_arg_uncons, param[0]);
  var match$1 = Curry._1(B_uncons, param[1]);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      var x = match[0];
      if (!Caml_obj.caml_equal(x, match$1[0])) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "steque_test.re",
                42,
                6
              ],
              Error: new Error()
            };
      }
      return [
              x,
              make(match[1], match$1[1])
            ];
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "steque_test.re",
            44,
            11
          ],
          Error: new Error()
        };
  }
  if (match$1 === undefined) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "steque_test.re",
          44,
          11
        ],
        Error: new Error()
      };
}

function append(param, param$1) {
  return make(Curry._2(partial_arg_append, param[0], param$1[0]), Curry._2(B_append, param[1], param$1[1]));
}

function length(param) {
  return Curry._1(partial_arg_length, param[0]);
}

var D2 = {
  compare_prefix: compare_prefix,
  make: make,
  empty: empty,
  cons: cons,
  snoc: snoc,
  uncons: uncons,
  append: append,
  length: length
};

var counter = {
  contents: 0
};

function elt(param) {
  counter.contents = counter.contents + 1 | 0;
  return counter.contents;
}

function some_snd(t, param) {
  if (param !== undefined) {
    return param[1];
  } else {
    return t;
  }
}

Random.init(9);

function test(n, t) {
  var match = Random.$$int(5);
  switch (match) {
    case 0 :
        return [
                n,
                Curry._2(cons, (counter.contents = counter.contents + 1 | 0, counter.contents), t)
              ];
    case 1 :
        return [
                n,
                Curry._2(snoc, t, (counter.contents = counter.contents + 1 | 0, counter.contents))
              ];
    case 2 :
        return [
                n,
                some_snd(t, Curry._1(uncons, t))
              ];
    case 3 :
        return [
                n,
                Curry._2(append, t, t)
              ];
    case 4 :
        var fuel = Random.$$int(n);
        var t$prime = test_repeatedly(fuel, empty);
        return [
                n - fuel | 0,
                Curry._2(append, t, t$prime)
              ];
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "steque_test.re",
              78,
              9
            ],
            Error: new Error()
          };
  }
}

function test_repeatedly(_n, _t) {
  while(true) {
    var t = _t;
    var n = _n;
    if (n <= 0) {
      return t;
    }
    var match = test(n, t);
    _t = match[1];
    _n = match[0] - 1 | 0;
    continue ;
  };
}

var match = test_repeatedly(1000, empty);

var s = match[0];

var xs = Curry._1(Deque.Steque.to_list, s);

var ys = Curry._1(Deque.Deck.to_list, match[1]);

if (!Caml_obj.caml_equal(xs, ys)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "steque_test.re",
          93,
          2
        ],
        Error: new Error()
      };
}

if (List.length(xs) !== Deque.Steque.length(s)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "steque_test.re",
          94,
          2
        ],
        Error: new Error()
      };
}

export {
  Bi ,
  D2 ,
  counter ,
  elt ,
  some_snd ,
  test ,
  test_repeatedly ,
  
}
/* empty Not a pure module */
