// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Dequeue_internal from "./dequeue_internal.bs.js";

function vector_fold_right(fn, v, z) {
  if (typeof v === "number") {
    return z;
  }
  switch (v.TAG | 0) {
    case /* V1 */0 :
        return Curry._2(fn, v._0, z);
    case /* V2 */1 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, z));
    case /* V3 */2 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, z)));
    case /* V4 */3 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, Curry._2(fn, v._3, z))));
    case /* V5 */4 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, Curry._2(fn, v._3, Curry._2(fn, v._4, z)))));
    case /* V6 */5 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, Curry._2(fn, v._3, Curry._2(fn, v._4, Curry._2(fn, v._5, z))))));
    
  }
}

function vector_fold_left(fn, z, v) {
  if (typeof v === "number") {
    return z;
  }
  switch (v.TAG | 0) {
    case /* V1 */0 :
        return Curry._2(fn, z, v._0);
    case /* V2 */1 :
        return Curry._2(fn, Curry._2(fn, z, v._0), v._1);
    case /* V3 */2 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2);
    case /* V4 */3 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2), v._3);
    case /* V5 */4 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2), v._3), v._4);
    case /* V6 */5 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2), v._3), v._4), v._5);
    
  }
}

function elt_out(x, t) {
  if (Dequeue_internal.is_rev(t)) {
    if (x.TAG === /* L2R */0) {
      return {
              TAG: /* R2L */1,
              _0: x._0
            };
    } else {
      return {
              TAG: /* L2R */0,
              _0: x._0
            };
    }
  } else {
    return x;
  }
}

var rev = Dequeue_internal.rev;

var is_rev = Dequeue_internal.is_rev;

function cons(x, t) {
  return Dequeue_internal.cons(elt_out(x, t), t);
}

function snoc(t, x) {
  return Dequeue_internal.snoc(t, elt_out(x, t));
}

function opt_uncons(t) {
  var match = Dequeue_internal.uncons(t);
  if (match !== undefined) {
    return [
            elt_out(match[0], t),
            match[1]
          ];
  }
  
}

function opt_unsnoc(t) {
  var match = Dequeue_internal.unsnoc(t);
  if (match !== undefined) {
    return [
            match[0],
            elt_out(match[1], t)
          ];
  }
  
}

function uncons(t) {
  var match = opt_uncons(t);
  if (match !== undefined) {
    return [
            match[0],
            match[1]
          ];
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "deckrev_internal.ml",
          188,
          14
        ],
        Error: new Error()
      };
}

function unsnoc(t) {
  var match = opt_unsnoc(t);
  if (match !== undefined) {
    return [
            match[0],
            match[1]
          ];
  } else {
    return Pervasives.failwith("unsnoc unsafe?");
  }
}

function single_elt(x) {
  return Dequeue_internal.cons(x, Dequeue_internal.empty);
}

function triple(x, y, z) {
  return cons(x, cons(y, Dequeue_internal.cons(z, Dequeue_internal.empty)));
}

function pair_elt(x, y) {
  return Dequeue_internal.cons(x, Dequeue_internal.cons(y, Dequeue_internal.empty));
}

function uncons2(t) {
  var match = uncons(t);
  var match$1 = uncons(match[1]);
  return [
          match[0],
          match$1[0],
          match$1[1]
        ];
}

function unsnoc2(t) {
  var match = unsnoc(t);
  var match$1 = unsnoc(match[0]);
  return [
          match$1[0],
          match$1[1],
          match[1]
        ];
}

function two(t) {
  var match = uncons2(t);
  if (!Dequeue_internal.is_empty(match[2])) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "deckrev_internal.ml",
            213,
            4
          ],
          Error: new Error()
        };
  }
  return [
          match[0],
          match[1]
        ];
}

function has1(t) {
  if (Dequeue_internal.is_empty(t)) {
    return /* Exact_0 */0;
  } else {
    return /* Lte1 */{
            _0: t
          };
  }
}

function to_dequeue(t) {
  return t;
}

function of_dequeue(d) {
  if (Dequeue_internal.is_empty(d)) {
    return /* Exact_0 */0;
  } else {
    return /* Lte1 */{
            _0: d
          };
  }
}

function snoc2(t, param) {
  return snoc(snoc(t, param[0]), param[1]);
}

function cons2(param, t) {
  return cons(param[0], cons(param[1], t));
}

function cons6(param, t) {
  return cons(param[0], cons(param[1], cons(param[2], cons(param[3], cons(param[4], cons(param[5], t))))));
}

function snoc6(t, param) {
  return snoc(snoc(snoc(snoc(snoc(snoc(t, param[0]), param[1]), param[2]), param[3]), param[4]), param[5]);
}

function uncons3(t) {
  var match = opt_uncons(t);
  if (match === undefined) {
    return {
            TAG: /* Not_enough */0,
            _0: /* V0 */0
          };
  }
  var x = match[0];
  var match$1 = opt_uncons(match[1]);
  if (match$1 === undefined) {
    return {
            TAG: /* Not_enough */0,
            _0: {
              TAG: /* V1 */0,
              _0: x
            }
          };
  }
  var y = match$1[0];
  var match$2 = opt_uncons(match$1[1]);
  if (match$2 !== undefined) {
    return {
            TAG: /* Enough */1,
            _0: {
              TAG: /* V3 */2,
              _0: x,
              _1: y,
              _2: match$2[0]
            },
            _1: match$2[1]
          };
  } else {
    return {
            TAG: /* Not_enough */0,
            _0: {
              TAG: /* V2 */1,
              _0: x,
              _1: y
            }
          };
  }
}

function uncons5(t) {
  var match = uncons2(t);
  var match$1 = uncons2(match[2]);
  var match$2 = uncons(match$1[2]);
  return [
          [
            match[0],
            match[1],
            match$1[0],
            match$1[1],
            match$2[0]
          ],
          match$2[1]
        ];
}

function has8(buffer) {
  var match = uncons5(buffer);
  var vec = uncons3(match[1]);
  if (vec.TAG === /* Not_enough */0) {
    return {
            TAG: /* Less_than_8 */0,
            _0: [
              match[0],
              vec._0
            ]
          };
  } else {
    return {
            TAG: /* At_least_8 */1,
            _0: buffer
          };
  }
}

function has5(buffer) {
  var match = uncons2(buffer);
  var match$1 = uncons2(match[2]);
  var match$2 = has1(match$1[2]);
  if (match$2) {
    return {
            TAG: /* At_least_5 */1,
            _0: buffer
          };
  } else {
    return {
            TAG: /* Exact_4 */0,
            _0: [
              match[0],
              match[1],
              match$1[0],
              match$1[1]
            ]
          };
  }
}

function cons_vector(v, t) {
  return vector_fold_right(cons, v, t);
}

function snoc_vector(t, v) {
  return vector_fold_left(snoc, t, v);
}

function has5p2(t) {
  var match = unsnoc(t);
  var a = match[1];
  var match$1 = opt_unsnoc(match[0]);
  if (match$1 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V1 */0,
              _0: a
            }
          };
  }
  var t5 = match$1[0];
  var b = match$1[1];
  var match$2 = opt_unsnoc(t5);
  if (match$2 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V2 */1,
              _0: b,
              _1: a
            }
          };
  }
  var c = match$2[1];
  var match$3 = opt_unsnoc(match$2[0]);
  if (match$3 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V3 */2,
              _0: c,
              _1: b,
              _2: a
            }
          };
  }
  var d = match$3[1];
  var match$4 = opt_unsnoc(match$3[0]);
  if (match$4 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V4 */3,
              _0: d,
              _1: c,
              _2: b,
              _3: a
            }
          };
  }
  var e = match$4[1];
  var match$5 = opt_unsnoc(match$4[0]);
  if (match$5 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V5 */4,
              _0: e,
              _1: d,
              _2: c,
              _3: b,
              _4: a
            }
          };
  }
  var match$6 = opt_unsnoc(match$5[0]);
  if (match$6 !== undefined) {
    return {
            TAG: /* At_least_5p2 */1,
            _0: t5,
            _1: b,
            _2: a
          };
  } else {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V6 */5,
              _0: match$5[1],
              _1: e,
              _2: d,
              _3: c,
              _4: b,
              _5: a
            }
          };
  }
}

function has2p5(t) {
  var match = uncons(t);
  var a = match[0];
  var match$1 = opt_uncons(match[1]);
  if (match$1 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V1 */0,
              _0: a
            }
          };
  }
  var t5 = match$1[1];
  var b = match$1[0];
  var match$2 = opt_uncons(t5);
  if (match$2 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V2 */1,
              _0: a,
              _1: b
            }
          };
  }
  var c = match$2[0];
  var match$3 = opt_uncons(match$2[1]);
  if (match$3 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V3 */2,
              _0: a,
              _1: b,
              _2: c
            }
          };
  }
  var d = match$3[0];
  var match$4 = opt_uncons(match$3[1]);
  if (match$4 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V4 */3,
              _0: a,
              _1: b,
              _2: c,
              _3: d
            }
          };
  }
  var e = match$4[0];
  var match$5 = opt_uncons(match$4[1]);
  if (match$5 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V5 */4,
              _0: a,
              _1: b,
              _2: c,
              _3: d,
              _4: e
            }
          };
  }
  var match$6 = opt_uncons(match$5[1]);
  if (match$6 !== undefined) {
    return {
            TAG: /* At_least_2p5 */1,
            _0: a,
            _1: b,
            _2: t5
          };
  } else {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V6 */5,
              _0: a,
              _1: b,
              _2: c,
              _3: d,
              _4: e,
              _5: match$5[0]
            }
          };
  }
}

function has3p8(t) {
  var match = uncons2(t);
  var b = match[1];
  var a = match[0];
  var match$1 = uncons(match[2]);
  var t8 = match$1[1];
  var c = match$1[0];
  var match$2 = uncons2(t8);
  var match$3 = uncons2(match$2[2]);
  var match$4 = uncons(match$3[2]);
  var vec = uncons3(match$4[1]);
  if (vec.TAG === /* Not_enough */0) {
    return {
            TAG: /* Less_than_11 */0,
            _0: [
              a,
              b,
              c,
              match$2[0],
              match$2[1],
              match$3[0],
              match$3[1],
              match$4[0]
            ],
            _1: vec._0
          };
  } else {
    return {
            TAG: /* At_least_11 */1,
            _0: a,
            _1: b,
            _2: c,
            _3: t8
          };
  }
}

function snoc5(t, param) {
  return snoc(snoc(snoc(snoc(snoc(t, param[0]), param[1]), param[2]), param[3]), param[4]);
}

function cons_5_vector(param, t) {
  var param$1 = param[0];
  var t$1 = vector_fold_right(cons, param[1], t);
  return cons(param$1[0], cons(param$1[1], cons(param$1[2], cons(param$1[3], cons(param$1[4], t$1)))));
}

function snoc_5_vector(t, param) {
  return vector_fold_left(snoc, snoc5(t, param[0]), param[1]);
}

function snoc8(t, param) {
  return snoc(snoc(snoc(snoc(snoc(snoc(snoc(snoc(t, param[0]), param[1]), param[2]), param[3]), param[4]), param[5]), param[6]), param[7]);
}

var $$Buffer = {
  empty: Dequeue_internal.empty,
  rev: rev,
  is_rev: is_rev,
  elt_out: elt_out,
  cons: cons,
  snoc: snoc,
  uncons: uncons,
  unsnoc: unsnoc,
  uncons2: uncons2,
  unsnoc2: unsnoc2,
  single_elt: single_elt,
  triple: triple,
  pair_elt: pair_elt,
  two: two,
  cons2: cons2,
  snoc2: snoc2,
  cons_5_vector: cons_5_vector,
  snoc_5_vector: snoc_5_vector,
  cons6: cons6,
  snoc6: snoc6,
  snoc8: snoc8,
  cons_vector: cons_vector,
  snoc_vector: snoc_vector,
  has1: has1,
  to_dequeue: to_dequeue,
  of_dequeue: of_dequeue,
  has5: has5,
  has5p2: has5p2,
  has2p5: has2p5,
  has8: has8,
  has3p8: has3p8
};

function is_empty(param) {
  if (typeof param._0 === "number") {
    return true;
  } else {
    return false;
  }
}

function triple_rev(t) {
  if (typeof t === "number") {
    return /* HOLE */0;
  } else if (t.TAG === /* Triple_rev */0) {
    return t._0;
  } else {
    return {
            TAG: /* Triple_rev */0,
            _0: t
          };
  }
}

function path_rev(param) {
  return /* Path */{
          _0: triple_rev(param._0),
          _1: triple_rev(param._1)
        };
}

function deque_rev(p) {
  switch (p.TAG | 0) {
    case /* Only_path */0 :
        return {
                TAG: /* Only_path */0,
                _0: path_rev(p._0)
              };
    case /* Pair_green */1 :
        return {
                TAG: /* Pair_green */1,
                _0: path_rev(p._1),
                _1: path_rev(p._0)
              };
    case /* Pair_red */2 :
        return {
                TAG: /* Pair_red */2,
                _0: path_rev(p._1),
                _1: path_rev(p._0)
              };
    
  }
}

function not_empty_rev(t) {
  switch (t.TAG | 0) {
    case /* Only_of */0 :
        return {
                TAG: /* Only_of */0,
                _0: triple_rev(t._0)
              };
    case /* Pair_left */1 :
        return {
                TAG: /* Pair_left_sym */3,
                _0: path_rev(t._1),
                _1: triple_rev(t._0)
              };
    case /* Pair_right */2 :
        return {
                TAG: /* Pair_right_sym */4,
                _0: triple_rev(t._1),
                _1: path_rev(t._0)
              };
    case /* Pair_left_sym */3 :
        return {
                TAG: /* Pair_left */1,
                _0: triple_rev(t._1),
                _1: path_rev(t._0)
              };
    case /* Pair_right_sym */4 :
        return {
                TAG: /* Pair_right */2,
                _0: path_rev(t._1),
                _1: triple_rev(t._0)
              };
    
  }
}

function st_rev(deq) {
  if (typeof deq === "number") {
    return /* Void */0;
  } else if (deq.TAG === /* T */0) {
    return {
            TAG: /* Rev */1,
            _0: deq._0
          };
  } else {
    return {
            TAG: /* T */0,
            _0: deq._0
          };
  }
}

function triple_force_rev(buf) {
  if (typeof buf === "number") {
    return /* HOLE */0;
  }
  switch (buf.TAG | 0) {
    case /* Only_prefix */1 :
        return {
                TAG: /* Only_prefix */1,
                _0: Dequeue_internal.rev(buf._0)
              };
    case /* Only_green */2 :
        return {
                TAG: /* Only_green */2,
                _0: Dequeue_internal.rev(buf._2),
                _1: deque_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Only_yellow */3 :
        return {
                TAG: /* Only_yellow */3,
                _0: Dequeue_internal.rev(buf._2),
                _1: not_empty_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Only_orange */4 :
        return {
                TAG: /* Only_orange */4,
                _0: Dequeue_internal.rev(buf._2),
                _1: not_empty_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Only_red */5 :
        return {
                TAG: /* Only_red */5,
                _0: Dequeue_internal.rev(buf._2),
                _1: deque_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Left_small */6 :
        return {
                TAG: /* Right_small */11,
                _0: Dequeue_internal.rev(buf._1),
                _1: Dequeue_internal.rev(buf._0)
              };
    case /* Left_green */7 :
        return {
                TAG: /* Right_green */12,
                _0: Dequeue_internal.rev(buf._2),
                _1: deque_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Left_yellow */8 :
        return {
                TAG: /* Right_yellow */13,
                _0: Dequeue_internal.rev(buf._2),
                _1: not_empty_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Left_orange */9 :
        return {
                TAG: /* Right_orange */14,
                _0: Dequeue_internal.rev(buf._2),
                _1: not_empty_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Left_red */10 :
        return {
                TAG: /* Right_red */15,
                _0: Dequeue_internal.rev(buf._2),
                _1: deque_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Right_small */11 :
        return {
                TAG: /* Left_small */6,
                _0: Dequeue_internal.rev(buf._1),
                _1: Dequeue_internal.rev(buf._0)
              };
    case /* Right_green */12 :
        return {
                TAG: /* Left_green */7,
                _0: Dequeue_internal.rev(buf._2),
                _1: deque_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Right_yellow */13 :
        return {
                TAG: /* Left_yellow */8,
                _0: Dequeue_internal.rev(buf._2),
                _1: not_empty_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Right_orange */14 :
        return {
                TAG: /* Left_orange */9,
                _0: Dequeue_internal.rev(buf._2),
                _1: not_empty_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    case /* Right_red */15 :
        return {
                TAG: /* Left_red */10,
                _0: Dequeue_internal.rev(buf._2),
                _1: deque_rev(buf._1),
                _2: Dequeue_internal.rev(buf._0)
              };
    
  }
}

function triple_not_rev(t) {
  if (typeof t === "number" || t.TAG !== /* Triple_rev */0) {
    return t;
  } else {
    return triple_force_rev(t._0);
  }
}

function cons_only_triple(x, triple) {
  var triple$1 = triple_not_rev(triple);
  if (typeof triple$1 !== "number") {
    switch (triple$1.TAG | 0) {
      case /* Only_prefix */1 :
          return {
                  TAG: /* Only_prefix */1,
                  _0: cons(x, triple$1._0)
                };
      case /* Only_green */2 :
          return {
                  TAG: /* Only_green */2,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      case /* Only_yellow */3 :
          return {
                  TAG: /* Only_yellow */3,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      case /* Only_orange */4 :
          return {
                  TAG: /* Only_orange */4,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      case /* Only_red */5 :
          return {
                  TAG: /* Only_red */5,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      
    }
  }
  
}

function snoc_only_triple(triple, x) {
  var triple$1 = triple_not_rev(triple);
  if (typeof triple$1 !== "number") {
    switch (triple$1.TAG | 0) {
      case /* Only_prefix */1 :
          return {
                  TAG: /* Only_prefix */1,
                  _0: snoc(triple$1._0, x)
                };
      case /* Only_green */2 :
          return {
                  TAG: /* Only_green */2,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      case /* Only_yellow */3 :
          return {
                  TAG: /* Only_yellow */3,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      case /* Only_orange */4 :
          return {
                  TAG: /* Only_orange */4,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      case /* Only_red */5 :
          return {
                  TAG: /* Only_red */5,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      
    }
  }
  
}

function is_hole(param) {
  if (typeof param === "number" || param.TAG === /* Triple_rev */0 && typeof param._0 === "number") {
    return /* Is_hole */0;
  } else {
    return /* Not_hole */1;
  }
}

function cons_only_path(x, param) {
  var kont = param._1;
  var only = param._0;
  var match = is_hole(only);
  if (match) {
    return /* Path */{
            _0: cons_only_triple(x, only),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: only,
            _1: cons_only_triple(x, kont)
          };
  }
}

function snoc_only_path(param, x) {
  var kont = param._1;
  var only = param._0;
  var match = is_hole(only);
  if (match) {
    return /* Path */{
            _0: snoc_only_triple(only, x),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: only,
            _1: snoc_only_triple(kont, x)
          };
  }
}

function cons_left_triple(x, triple) {
  var triple$1 = triple_not_rev(triple);
  if (typeof triple$1 !== "number") {
    switch (triple$1.TAG | 0) {
      case /* Left_small */6 :
          return {
                  TAG: /* Left_small */6,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1
                };
      case /* Left_green */7 :
          return {
                  TAG: /* Left_green */7,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      case /* Left_yellow */8 :
          return {
                  TAG: /* Left_yellow */8,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      case /* Left_orange */9 :
          return {
                  TAG: /* Left_orange */9,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      case /* Left_red */10 :
          return {
                  TAG: /* Left_red */10,
                  _0: cons(x, triple$1._0),
                  _1: triple$1._1,
                  _2: triple$1._2
                };
      
    }
  }
  
}

function snoc_right_triple(triple, x) {
  var triple$1 = triple_not_rev(triple);
  if (typeof triple$1 !== "number") {
    switch (triple$1.TAG | 0) {
      case /* Right_small */11 :
          return {
                  TAG: /* Right_small */11,
                  _0: triple$1._0,
                  _1: snoc(triple$1._1, x)
                };
      case /* Right_green */12 :
          return {
                  TAG: /* Right_green */12,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      case /* Right_yellow */13 :
          return {
                  TAG: /* Right_yellow */13,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      case /* Right_orange */14 :
          return {
                  TAG: /* Right_orange */14,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      case /* Right_red */15 :
          return {
                  TAG: /* Right_red */15,
                  _0: triple$1._0,
                  _1: triple$1._1,
                  _2: snoc(triple$1._2, x)
                };
      
    }
  }
  
}

function cons_left_path(x, param) {
  var kont = param._1;
  var left = param._0;
  var match = is_hole(left);
  if (match) {
    return /* Path */{
            _0: cons_left_triple(x, left),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: left,
            _1: cons_left_triple(x, kont)
          };
  }
}

function snoc_right_path(param, x) {
  var kont = param._1;
  var right = param._0;
  var match = is_hole(right);
  if (match) {
    return /* Path */{
            _0: snoc_right_triple(right, x),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: right,
            _1: snoc_right_triple(kont, x)
          };
  }
}

function cons_deque(x, deq) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return {
                TAG: /* Only_path */0,
                _0: cons_only_path(x, deq._0)
              };
    case /* Pair_green */1 :
        return {
                TAG: /* Pair_green */1,
                _0: cons_left_path(x, deq._0),
                _1: deq._1
              };
    case /* Pair_red */2 :
        return {
                TAG: /* Pair_red */2,
                _0: cons_left_path(x, deq._0),
                _1: deq._1
              };
    
  }
}

function snoc_deque(deq, x) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return {
                TAG: /* Only_path */0,
                _0: snoc_only_path(deq._0, x)
              };
    case /* Pair_green */1 :
        return {
                TAG: /* Pair_green */1,
                _0: deq._0,
                _1: snoc_right_path(deq._1, x)
              };
    case /* Pair_red */2 :
        return {
                TAG: /* Pair_red */2,
                _0: deq._0,
                _1: snoc_right_path(deq._1, x)
              };
    
  }
}

function single_triple(x) {
  return {
          TAG: /* Only_prefix */1,
          _0: Dequeue_internal.cons(x, Dequeue_internal.empty)
        };
}

function only_single(x) {
  return {
          TAG: /* Only_path */0,
          _0: /* Path */{
            _0: /* HOLE */0,
            _1: {
              TAG: /* Only_prefix */1,
              _0: Dequeue_internal.cons(x, Dequeue_internal.empty)
            }
          }
        };
}

function single(x) {
  return {
          TAG: /* T */0,
          _0: only_single(x)
        };
}

function cons_t(x, t) {
  if (typeof t === "number") {
    return {
            TAG: /* T */0,
            _0: only_single(x)
          };
  } else if (t.TAG === /* T */0) {
    return {
            TAG: /* T */0,
            _0: cons_deque(x, t._0)
          };
  } else {
    return {
            TAG: /* Rev */1,
            _0: snoc_deque(t._0, x)
          };
  }
}

function snoc_t(t, x) {
  if (typeof t === "number") {
    return {
            TAG: /* T */0,
            _0: only_single(x)
          };
  } else if (t.TAG === /* T */0) {
    return {
            TAG: /* T */0,
            _0: snoc_deque(t._0, x)
          };
  } else {
    return {
            TAG: /* Rev */1,
            _0: cons_deque(x, t._0)
          };
  }
}

function cons$1(x, t) {
  return /* Regular */{
          _0: cons_t(x, t._0)
        };
}

function snoc$1(t, x) {
  return /* Regular */{
          _0: snoc_t(t._0, x)
        };
}

function cons_semi(x, t) {
  return /* S */{
          _0: cons_t(x, t._0)
        };
}

function snoc_semi(t, x) {
  return /* S */{
          _0: snoc_t(t._0, x)
        };
}

function cons_vector$1(v, t) {
  return vector_fold_right(cons$1, v, t);
}

function snoc_vector$1(t, v) {
  return vector_fold_left(snoc$1, t, v);
}

function cons_semi_vector(v, t) {
  return vector_fold_right(cons_semi, v, t);
}

function snoc_semi_vector(t, v) {
  return vector_fold_left(snoc_semi, t, v);
}

function color(param) {
  if (typeof param === "number") {
    return /* Is_green */0;
  }
  switch (param.TAG | 0) {
    case /* Triple_rev */0 :
        var tmp = param._0;
        if (typeof tmp === "number") {
          return /* Is_green */0;
        }
        switch (tmp.TAG | 0) {
          case /* Only_red */5 :
          case /* Left_red */10 :
          case /* Right_red */15 :
              return /* Is_red */1;
          default:
            return /* Is_green */0;
        }
    case /* Only_red */5 :
    case /* Left_red */10 :
    case /* Right_red */15 :
        return /* Is_red */1;
    default:
      return /* Is_green */0;
  }
}

function color_path(param) {
  return color(param._1);
}

function color_deque(t) {
  switch (t.TAG | 0) {
    case /* Only_path */0 :
        return color_path(t._0);
    case /* Pair_green */1 :
        return /* Is_red */1;
    case /* Pair_red */2 :
        return /* Is_green */0;
    
  }
}

function color_st(t) {
  if (typeof t === "number") {
    return /* Is_green */0;
  } else {
    return color_deque(t._0);
  }
}

function pref_left(param) {
  switch (param.TAG | 0) {
    case /* Only_path */0 :
        var match = param._0;
        return /* Pref_left */{
                _0: {
                  TAG: /* Only_of */0,
                  _0: match._0
                },
                _1: match._1
              };
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  var match$1 = param._0;
  return /* Pref_left */{
          _0: {
            TAG: /* Pair_left */1,
            _0: match$1._0,
            _1: param._1
          },
          _1: match$1._1
        };
}

function pref_right(deq, ft) {
  switch (deq.TAG | 0) {
    case /* Only_of */0 :
        return /* Pref_right */{
                _0: {
                  TAG: /* Only_of */0,
                  _0: deq._0
                },
                _1: ft
              };
    case /* Pair_left */1 :
        var match = deq._1;
        return /* Pref_right */{
                _0: {
                  TAG: /* Pair_right */2,
                  _0: /* Path */{
                    _0: deq._0,
                    _1: ft
                  },
                  _1: match._0
                },
                _1: match._1
              };
    case /* Pair_left_sym */3 :
        var match$1 = deq._0;
        return /* Pref_right */{
                _0: {
                  TAG: /* Pair_right_sym */4,
                  _0: match$1._0,
                  _1: /* Path */{
                    _0: deq._1,
                    _1: ft
                  }
                },
                _1: match$1._1
              };
    
  }
}

function no_pref(d1, ght) {
  switch (d1.TAG | 0) {
    case /* Only_of */0 :
        return {
                TAG: /* Only_path */0,
                _0: /* Path */{
                  _0: d1._0,
                  _1: ght
                }
              };
    case /* Pair_right */2 :
        return {
                TAG: /* Pair_red */2,
                _0: d1._0,
                _1: /* Path */{
                  _0: d1._1,
                  _1: ght
                }
              };
    case /* Pair_right_sym */4 :
        return {
                TAG: /* Pair_red */2,
                _0: /* Path */{
                  _0: d1._0,
                  _1: ght
                },
                _1: d1._1
              };
    
  }
}

function make_child(ne_deq, trip) {
  var match = color(trip);
  if (match) {
    var exit = 0;
    switch (ne_deq.TAG | 0) {
      case /* Only_of */0 :
          return /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: /* Path */{
                        _0: ne_deq._0,
                        _1: trip
                      }
                    }
                  }
                };
      case /* Pair_right */2 :
      case /* Pair_left_sym */3 :
          exit = 2;
          break;
      case /* Pair_left */1 :
      case /* Pair_right_sym */4 :
          exit = 1;
          break;
      
    }
    switch (exit) {
      case 1 :
          return /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Pair_green */1,
                      _0: /* Path */{
                        _0: ne_deq._0,
                        _1: trip
                      },
                      _1: ne_deq._1
                    }
                  }
                };
      case 2 :
          return /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Pair_green */1,
                      _0: ne_deq._0,
                      _1: /* Path */{
                        _0: ne_deq._1,
                        _1: trip
                      }
                    }
                  }
                };
      
    }
  } else {
    switch (ne_deq.TAG | 0) {
      case /* Only_of */0 :
          return /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: /* Path */{
                        _0: ne_deq._0,
                        _1: trip
                      }
                    }
                  }
                };
      case /* Pair_right */2 :
          return /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Pair_red */2,
                      _0: ne_deq._0,
                      _1: /* Path */{
                        _0: ne_deq._1,
                        _1: trip
                      }
                    }
                  }
                };
      case /* Pair_left_sym */3 :
          return /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Pair_green */1,
                      _0: ne_deq._0,
                      _1: /* Path */{
                        _0: ne_deq._1,
                        _1: trip
                      }
                    }
                  }
                };
      case /* Pair_left */1 :
      case /* Pair_right_sym */4 :
          break;
      
    }
    return /* S */{
            _0: {
              TAG: /* T */0,
              _0: {
                TAG: /* Pair_green */1,
                _0: /* Path */{
                  _0: ne_deq._0,
                  _1: trip
                },
                _1: ne_deq._1
              }
            }
          };
  }
}

function cons_child(x, ne_deq, trip) {
  switch (ne_deq.TAG | 0) {
    case /* Only_of */0 :
        var only = ne_deq._0;
        var match = is_hole(only);
        if (match) {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: cons_only_triple(x, only)
                  },
                  triple_not_rev(trip)
                ];
        } else {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: only
                  },
                  cons_only_triple(x, trip)
                ];
        }
    case /* Pair_left */1 :
        var right = ne_deq._1;
        var left = ne_deq._0;
        var match$1 = is_hole(left);
        if (match$1) {
          return [
                  {
                    TAG: /* Pair_left */1,
                    _0: cons_left_triple(x, left),
                    _1: right
                  },
                  triple_not_rev(trip)
                ];
        } else {
          return [
                  {
                    TAG: /* Pair_left */1,
                    _0: left,
                    _1: right
                  },
                  cons_left_triple(x, trip)
                ];
        }
    case /* Pair_right */2 :
        return [
                {
                  TAG: /* Pair_right */2,
                  _0: cons_left_path(x, ne_deq._0),
                  _1: ne_deq._1
                },
                triple_not_rev(trip)
              ];
    case /* Pair_left_sym */3 :
        return [
                {
                  TAG: /* Pair_left_sym */3,
                  _0: cons_left_path(x, ne_deq._0),
                  _1: ne_deq._1
                },
                triple_not_rev(trip)
              ];
    case /* Pair_right_sym */4 :
        var right$1 = ne_deq._1;
        var left$1 = ne_deq._0;
        var match$2 = is_hole(left$1);
        if (match$2) {
          return [
                  {
                    TAG: /* Pair_right_sym */4,
                    _0: cons_left_triple(x, left$1),
                    _1: right$1
                  },
                  triple_not_rev(trip)
                ];
        } else if (typeof left$1 === "number") {
          return [
                  {
                    TAG: /* Pair_right_sym */4,
                    _0: /* HOLE */0,
                    _1: right$1
                  },
                  cons_left_triple(x, trip)
                ];
        } else {
          return [
                  {
                    TAG: /* Pair_right_sym */4,
                    _0: left$1,
                    _1: right$1
                  },
                  cons_left_triple(x, trip)
                ];
        }
    
  }
}

function snoc_child(ne_deq, trip, x) {
  switch (ne_deq.TAG | 0) {
    case /* Only_of */0 :
        var only = ne_deq._0;
        var match = is_hole(only);
        if (match) {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: snoc_only_triple(only, x)
                  },
                  triple_not_rev(trip)
                ];
        } else {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: only
                  },
                  snoc_only_triple(trip, x)
                ];
        }
    case /* Pair_left */1 :
        return [
                {
                  TAG: /* Pair_left */1,
                  _0: ne_deq._0,
                  _1: snoc_right_path(ne_deq._1, x)
                },
                triple_not_rev(trip)
              ];
    case /* Pair_right */2 :
        var right = ne_deq._1;
        var left = ne_deq._0;
        var match$1 = is_hole(right);
        if (match$1) {
          return [
                  {
                    TAG: /* Pair_right */2,
                    _0: left,
                    _1: snoc_right_triple(right, x)
                  },
                  triple_not_rev(trip)
                ];
        } else {
          return [
                  {
                    TAG: /* Pair_right */2,
                    _0: left,
                    _1: right
                  },
                  snoc_right_triple(trip, x)
                ];
        }
    case /* Pair_left_sym */3 :
        var right$1 = ne_deq._1;
        var left$1 = ne_deq._0;
        var match$2 = is_hole(right$1);
        if (match$2) {
          return [
                  {
                    TAG: /* Pair_left_sym */3,
                    _0: left$1,
                    _1: snoc_right_triple(right$1, x)
                  },
                  triple_not_rev(trip)
                ];
        } else {
          return [
                  {
                    TAG: /* Pair_left_sym */3,
                    _0: left$1,
                    _1: right$1
                  },
                  snoc_right_triple(trip, x)
                ];
        }
    case /* Pair_right_sym */4 :
        return [
                {
                  TAG: /* Pair_right_sym */4,
                  _0: ne_deq._0,
                  _1: snoc_right_path(ne_deq._1, x)
                },
                triple_not_rev(trip)
              ];
    
  }
}

function stored_left(p2, d2, s2, s1) {
  var s2$1 = vector_fold_left(snoc, snoc(s2, s1[0]), s1[1]);
  var match = uncons(p2);
  var match$1 = uncons(match[1]);
  var s3 = pair_elt(match[0], match$1[0]);
  return [
          s3,
          {
            TAG: /* Stored */1,
            _0: match$1[1],
            _1: d2,
            _2: s2$1
          }
        ];
}

function stored_right(s1, p2, d2, s2) {
  var p2$1 = cons(s1[0], vector_fold_right(cons, s1[1], p2));
  var match = unsnoc2(s2);
  var s3 = pair_elt(match[1], match[2]);
  return [
          {
            TAG: /* Stored */1,
            _0: p2$1,
            _1: d2,
            _2: match[0]
          },
          s3
        ];
}

function extract_stored_left(param, s1) {
  var t = triple_not_rev(param._0);
  var kont = triple_not_rev(param._1);
  if (typeof t === "number") {
    if (typeof kont !== "number") {
      switch (kont.TAG | 0) {
        case /* Left_small */6 :
            return stored_left(kont._0, /* Void */0, kont._1, s1);
        case /* Left_green */7 :
        case /* Left_red */10 :
            break;
        
      }
    }
    return stored_left(kont._0, {
                TAG: /* T */0,
                _0: kont._1
              }, kont._2, s1);
  }
  var d2 = make_child(t._1, kont);
  return stored_left(t._0, d2._0, t._2, s1);
}

function extract_stored_right(s1, param) {
  var t = triple_not_rev(param._0);
  var kont = triple_not_rev(param._1);
  if (typeof t === "number") {
    if (typeof kont !== "number") {
      switch (kont.TAG | 0) {
        case /* Right_small */11 :
            return stored_right(s1, kont._0, /* Void */0, kont._1);
        case /* Right_green */12 :
        case /* Right_red */15 :
            break;
        
      }
    }
    return stored_right(s1, kont._0, {
                TAG: /* T */0,
                _0: kont._1
              }, kont._2);
  }
  var d2 = make_child(t._1, kont);
  return stored_right(s1, t._0, d2._0, t._2);
}

function path_not_rev(param) {
  return /* Path_nr */{
          _0: triple_not_rev(param._0),
          _1: triple_not_rev(param._1)
        };
}

function left_of_pair(left, right) {
  var match = color_path(left);
  var match$1 = path_not_rev(left);
  var match$2 = match$1._0;
  if (typeof match$2 === "number") {
    if (match) {
      var match$3 = match$1._1;
      var match$4 = two(match$3._2);
      var s1_0 = match$4[0];
      var s1_1 = {
        TAG: /* V1 */0,
        _0: match$4[1]
      };
      var s1 = [
        s1_0,
        s1_1
      ];
      var match$5 = extract_stored_right(s1, right);
      var d1 = snoc_deque(match$3._1, {
            TAG: /* L2R */0,
            _0: match$5[0]
          });
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Left_red */10,
                _0: match$3._0,
                _1: d1,
                _2: match$5[1]
              }
            };
    }
    var match$6 = match$1._1;
    if (typeof match$6 !== "number") {
      if (match$6.TAG === /* Left_small */6) {
        var match$7 = two(match$6._1);
        var p1 = snoc(match$6._0, match$7[0]);
        var s1_0$1 = match$7[1];
        var s1$1 = [
          s1_0$1,
          /* V0 */0
        ];
        var match$8 = extract_stored_right(s1$1, right);
        var kont = {
          TAG: /* Only_prefix */1,
          _0: Dequeue_internal.cons({
                TAG: /* L2R */0,
                _0: match$8[0]
              }, Dequeue_internal.empty)
        };
        return /* Path */{
                _0: {
                  TAG: /* Left_orange */9,
                  _0: p1,
                  _1: {
                    TAG: /* Only_of */0,
                    _0: /* HOLE */0
                  },
                  _2: match$8[1]
                },
                _1: kont
              };
      }
      var match$9 = two(match$6._2);
      var s1_0$2 = match$9[0];
      var s1_1$1 = {
        TAG: /* V1 */0,
        _0: match$9[1]
      };
      var s1$2 = [
        s1_0$2,
        s1_1$1
      ];
      var match$10 = extract_stored_right(s1$2, right);
      var d1$1 = snoc_deque(match$6._1, {
            TAG: /* L2R */0,
            _0: match$10[0]
          });
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Left_green */7,
                _0: match$6._0,
                _1: d1$1,
                _2: match$10[1]
              }
            };
    }
    
  } else {
    if (match$2.TAG === /* Left_yellow */8) {
      var match$11 = two(match$2._2);
      var s1_0$3 = match$11[0];
      var s1_1$2 = {
        TAG: /* V1 */0,
        _0: match$11[1]
      };
      var s1$3 = [
        s1_0$3,
        s1_1$2
      ];
      var match$12 = extract_stored_right(s1$3, right);
      var match$13 = snoc_child(match$2._1, match$1._1, {
            TAG: /* L2R */0,
            _0: match$12[0]
          });
      return /* Path */{
              _0: {
                TAG: /* Left_yellow */8,
                _0: match$2._0,
                _1: match$13[0],
                _2: match$12[1]
              },
              _1: match$13[1]
            };
    }
    var match$14 = two(match$2._2);
    var s1_0$4 = match$14[0];
    var s1_1$3 = {
      TAG: /* V1 */0,
      _0: match$14[1]
    };
    var s1$4 = [
      s1_0$4,
      s1_1$3
    ];
    var match$15 = extract_stored_right(s1$4, right);
    var match$16 = snoc_child(match$2._1, match$1._1, {
          TAG: /* L2R */0,
          _0: match$15[0]
        });
    return /* Path */{
            _0: {
              TAG: /* Left_orange */9,
              _0: match$2._0,
              _1: match$16[0],
              _2: match$15[1]
            },
            _1: match$16[1]
          };
  }
}

function right_of_pair(left, right) {
  var match = color_path(right);
  var match$1 = path_not_rev(right);
  var match$2 = match$1._0;
  if (typeof match$2 === "number") {
    if (match) {
      var match$3 = match$1._1;
      var match$4 = two(match$3._0);
      var p1_0 = match$4[0];
      var p1_1 = {
        TAG: /* V1 */0,
        _0: match$4[1]
      };
      var p1 = [
        p1_0,
        p1_1
      ];
      var match$5 = extract_stored_left(left, p1);
      var d1 = cons_deque({
            TAG: /* L2R */0,
            _0: match$5[1]
          }, match$3._1);
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Right_red */15,
                _0: match$5[0],
                _1: d1,
                _2: match$3._2
              }
            };
    }
    var match$6 = match$1._1;
    if (typeof match$6 !== "number") {
      if (match$6.TAG === /* Right_small */11) {
        var match$7 = two(match$6._0);
        var p1_0$1 = match$7[0];
        var p1$1 = [
          p1_0$1,
          /* V0 */0
        ];
        var s1 = cons(match$7[1], match$6._1);
        var match$8 = extract_stored_left(left, p1$1);
        var kont = {
          TAG: /* Only_prefix */1,
          _0: Dequeue_internal.cons({
                TAG: /* L2R */0,
                _0: match$8[1]
              }, Dequeue_internal.empty)
        };
        return /* Path */{
                _0: {
                  TAG: /* Right_orange */14,
                  _0: match$8[0],
                  _1: {
                    TAG: /* Only_of */0,
                    _0: /* HOLE */0
                  },
                  _2: s1
                },
                _1: kont
              };
      }
      var match$9 = two(match$6._0);
      var p1_0$2 = match$9[0];
      var p1_1$1 = {
        TAG: /* V1 */0,
        _0: match$9[1]
      };
      var p1$2 = [
        p1_0$2,
        p1_1$1
      ];
      var match$10 = extract_stored_left(left, p1$2);
      var d1$1 = cons_deque({
            TAG: /* L2R */0,
            _0: match$10[1]
          }, match$6._1);
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Right_green */12,
                _0: match$10[0],
                _1: d1$1,
                _2: match$6._2
              }
            };
    }
    
  } else {
    if (match$2.TAG === /* Right_yellow */13) {
      var match$11 = two(match$2._0);
      var p1_0$3 = match$11[0];
      var p1_1$2 = {
        TAG: /* V1 */0,
        _0: match$11[1]
      };
      var p1$3 = [
        p1_0$3,
        p1_1$2
      ];
      var match$12 = extract_stored_left(left, p1$3);
      var match$13 = cons_child({
            TAG: /* L2R */0,
            _0: match$12[1]
          }, match$2._1, match$1._1);
      return /* Path */{
              _0: {
                TAG: /* Right_yellow */13,
                _0: match$12[0],
                _1: match$13[0],
                _2: match$2._2
              },
              _1: match$13[1]
            };
    }
    var match$14 = two(match$2._0);
    var p1_0$4 = match$14[0];
    var p1_1$3 = {
      TAG: /* V1 */0,
      _0: match$14[1]
    };
    var p1$4 = [
      p1_0$4,
      p1_1$3
    ];
    var match$15 = extract_stored_left(left, p1$4);
    var match$16 = cons_child({
          TAG: /* L2R */0,
          _0: match$15[1]
        }, match$2._1, match$1._1);
    return /* Path */{
            _0: {
              TAG: /* Right_orange */14,
              _0: match$15[0],
              _1: match$16[0],
              _2: match$2._2
            },
            _1: match$16[1]
          };
  }
}

function left_of_only(path) {
  var match = color_path(path);
  var match$1 = path_not_rev(path);
  var match$2 = match$1._0;
  if (typeof match$2 === "number") {
    if (match) {
      var match$3 = match$1._1;
      var match$4 = unsnoc2(match$3._2);
      var s1$prime = pair_elt(match$4[1], match$4[2]);
      var d1 = snoc_deque(match$3._1, {
            TAG: /* L2R */0,
            _0: {
              TAG: /* Stored_prefix */0,
              _0: match$4[0]
            }
          });
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Left_red */10,
                  _0: match$3._0,
                  _1: d1,
                  _2: s1$prime
                }
              }
            };
    }
    var p1 = match$1._1;
    if (typeof p1 !== "number") {
      if (p1.TAG === /* Only_prefix */1) {
        var vec = has5p2(p1._0);
        if (vec.TAG === /* Less_than_5p2 */0) {
          return {
                  TAG: /* Small */0,
                  _0: vec._0
                };
        }
        var s1 = pair_elt(vec._1, vec._2);
        return {
                TAG: /* Ok */1,
                _0: /* Path */{
                  _0: /* HOLE */0,
                  _1: {
                    TAG: /* Left_small */6,
                    _0: vec._0,
                    _1: s1
                  }
                }
              };
      }
      var match$5 = unsnoc2(p1._2);
      var s1$prime$1 = pair_elt(match$5[1], match$5[2]);
      var d1$1 = snoc_deque(p1._1, {
            TAG: /* L2R */0,
            _0: {
              TAG: /* Stored_prefix */0,
              _0: match$5[0]
            }
          });
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Left_green */7,
                  _0: p1._0,
                  _1: d1$1,
                  _2: s1$prime$1
                }
              }
            };
    }
    
  } else {
    if (match$2.TAG === /* Only_yellow */3) {
      var match$6 = unsnoc2(match$2._2);
      var s1$prime$2 = pair_elt(match$6[1], match$6[2]);
      var match$7 = snoc_child(match$2._1, match$1._1, {
            TAG: /* L2R */0,
            _0: {
              TAG: /* Stored_prefix */0,
              _0: match$6[0]
            }
          });
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: {
                  TAG: /* Left_yellow */8,
                  _0: match$2._0,
                  _1: match$7[0],
                  _2: s1$prime$2
                },
                _1: match$7[1]
              }
            };
    }
    var match$8 = unsnoc2(match$2._2);
    var s1$prime$3 = pair_elt(match$8[1], match$8[2]);
    var match$9 = snoc_child(match$2._1, match$1._1, {
          TAG: /* L2R */0,
          _0: {
            TAG: /* Stored_prefix */0,
            _0: match$8[0]
          }
        });
    return {
            TAG: /* Ok */1,
            _0: /* Path */{
              _0: {
                TAG: /* Left_orange */9,
                _0: match$2._0,
                _1: match$9[0],
                _2: s1$prime$3
              },
              _1: match$9[1]
            }
          };
  }
}

function right_of_only(path) {
  var match = color_path(path);
  var match$1 = path_not_rev(path);
  var match$2 = match$1._0;
  if (typeof match$2 === "number") {
    if (match) {
      var match$3 = match$1._1;
      var match$4 = uncons2(match$3._0);
      var d1 = cons_deque({
            TAG: /* L2R */0,
            _0: {
              TAG: /* Stored_prefix */0,
              _0: match$4[2]
            }
          }, match$3._1);
      var p1$prime = pair_elt(match$4[0], match$4[1]);
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Right_red */15,
                  _0: p1$prime,
                  _1: d1,
                  _2: match$3._2
                }
              }
            };
    }
    var p1 = match$1._1;
    if (typeof p1 !== "number") {
      if (p1.TAG === /* Only_prefix */1) {
        var vec = has2p5(p1._0);
        if (vec.TAG === /* Less_than_2p5 */0) {
          return {
                  TAG: /* Small */0,
                  _0: vec._0
                };
        }
        var p1$1 = pair_elt(vec._0, vec._1);
        return {
                TAG: /* Ok */1,
                _0: /* Path */{
                  _0: /* HOLE */0,
                  _1: {
                    TAG: /* Right_small */11,
                    _0: p1$1,
                    _1: vec._2
                  }
                }
              };
      }
      var match$5 = uncons2(p1._0);
      var d1$1 = cons_deque({
            TAG: /* L2R */0,
            _0: {
              TAG: /* Stored_prefix */0,
              _0: match$5[2]
            }
          }, p1._1);
      var p1$prime$1 = pair_elt(match$5[0], match$5[1]);
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Right_green */12,
                  _0: p1$prime$1,
                  _1: d1$1,
                  _2: p1._2
                }
              }
            };
    }
    
  } else {
    if (match$2.TAG === /* Only_yellow */3) {
      var match$6 = uncons2(match$2._0);
      var match$7 = cons_child({
            TAG: /* L2R */0,
            _0: {
              TAG: /* Stored_prefix */0,
              _0: match$6[2]
            }
          }, match$2._1, match$1._1);
      var p1$prime$2 = pair_elt(match$6[0], match$6[1]);
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: {
                  TAG: /* Right_yellow */13,
                  _0: p1$prime$2,
                  _1: match$7[0],
                  _2: match$2._2
                },
                _1: match$7[1]
              }
            };
    }
    var match$8 = uncons2(match$2._0);
    var match$9 = cons_child({
          TAG: /* L2R */0,
          _0: {
            TAG: /* Stored_prefix */0,
            _0: match$8[2]
          }
        }, match$2._1, match$1._1);
    var p1$prime$3 = pair_elt(match$8[0], match$8[1]);
    return {
            TAG: /* Ok */1,
            _0: /* Path */{
              _0: {
                TAG: /* Right_orange */14,
                _0: p1$prime$3,
                _1: match$9[0],
                _2: match$2._2
              },
              _1: match$9[1]
            }
          };
  }
}

function make_left(st) {
  var match = color_st(st);
  if (typeof st === "number") {
    return {
            TAG: /* Small */0,
            _0: /* V0 */0
          };
  }
  if (st.TAG === /* T */0) {
    var only = st._0;
    switch (only.TAG | 0) {
      case /* Only_path */0 :
          return left_of_only(only._0);
      case /* Pair_green */1 :
      case /* Pair_red */2 :
          break;
      
    }
  } else {
    var only$1 = st._0;
    switch (only$1.TAG | 0) {
      case /* Only_path */0 :
          return left_of_only(path_rev(only$1._0));
      case /* Pair_green */1 :
      case /* Pair_red */2 :
          break;
      
    }
  }
  if (match) {
    if (typeof st !== "number") {
      if (st.TAG === /* T */0) {
        var match$1 = st._0;
        return {
                TAG: /* Any */2,
                _0: left_of_pair(match$1._0, match$1._1)
              };
      }
      var match$2 = st._0;
      return {
              TAG: /* Any */2,
              _0: left_of_pair(path_rev(match$2._1), path_rev(match$2._0))
            };
    }
    
  } else if (typeof st !== "number") {
    if (st.TAG === /* T */0) {
      var match$3 = st._0;
      return {
              TAG: /* Ok */1,
              _0: left_of_pair(match$3._0, match$3._1)
            };
    }
    var match$4 = st._0;
    return {
            TAG: /* Ok */1,
            _0: left_of_pair(path_rev(match$4._1), path_rev(match$4._0))
          };
  }
  
}

function make_right(st) {
  var match = color_st(st);
  if (typeof st === "number") {
    return {
            TAG: /* Small */0,
            _0: /* V0 */0
          };
  }
  if (st.TAG === /* T */0) {
    var only = st._0;
    switch (only.TAG | 0) {
      case /* Only_path */0 :
          return right_of_only(only._0);
      case /* Pair_green */1 :
      case /* Pair_red */2 :
          break;
      
    }
  } else {
    var only$1 = st._0;
    switch (only$1.TAG | 0) {
      case /* Only_path */0 :
          return right_of_only(path_rev(only$1._0));
      case /* Pair_green */1 :
      case /* Pair_red */2 :
          break;
      
    }
  }
  if (match) {
    if (typeof st !== "number") {
      if (st.TAG === /* T */0) {
        var match$1 = st._0;
        return {
                TAG: /* Any */2,
                _0: right_of_pair(match$1._0, match$1._1)
              };
      }
      var match$2 = st._0;
      return {
              TAG: /* Any */2,
              _0: right_of_pair(path_rev(match$2._1), path_rev(match$2._0))
            };
    }
    
  } else if (typeof st !== "number") {
    if (st.TAG === /* T */0) {
      var match$3 = st._0;
      return {
              TAG: /* Ok */1,
              _0: right_of_pair(match$3._0, match$3._1)
            };
    }
    var match$4 = st._0;
    return {
            TAG: /* Ok */1,
            _0: right_of_pair(path_rev(match$4._1), path_rev(match$4._0))
          };
  }
  
}

function concat_semi(deq_left, deq_right) {
  var dr = deq_right._0;
  var vec = make_left(deq_left._0);
  switch (vec.TAG | 0) {
    case /* Small */0 :
        return cons_semi_vector(vec._0, deq_right);
    case /* Ok */1 :
        var vec$1 = make_right(dr);
        switch (vec$1.TAG | 0) {
          case /* Small */0 :
              return snoc_semi_vector(deq_left, vec$1._0);
          case /* Ok */1 :
          case /* Any */2 :
              break;
          
        }
        return /* S */{
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Pair_green */1,
                    _0: vec._0,
                    _1: vec$1._0
                  }
                }
              };
    case /* Any */2 :
        var vec$2 = make_right(dr);
        switch (vec$2.TAG | 0) {
          case /* Small */0 :
              return snoc_semi_vector(deq_left, vec$2._0);
          case /* Ok */1 :
          case /* Any */2 :
              break;
          
        }
        return /* S */{
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Pair_green */1,
                    _0: vec._0,
                    _1: vec$2._0
                  }
                }
              };
    
  }
}

function concat(deq_left, deq_right) {
  var vec = make_left(deq_left._0);
  if (vec.TAG === /* Small */0) {
    return cons_vector$1(vec._0, deq_right);
  }
  var vec$1 = make_right(deq_right._0);
  if (vec$1.TAG === /* Small */0) {
    return snoc_vector$1(deq_left, vec$1._0);
  } else {
    return /* Regular */{
            _0: {
              TAG: /* T */0,
              _0: {
                TAG: /* Pair_red */2,
                _0: vec._0,
                _1: vec$1._0
              }
            }
          };
  }
}

function semi_of_left(left, six) {
  var match = color_path(left);
  var match$1 = path_not_rev(left);
  if (match) {
    if (typeof match$1._0 === "number") {
      var match$2 = match$1._1;
      var s2 = snoc6(match$2._2, six);
      return /* S */{
              _0: {
                TAG: /* T */0,
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_red */5,
                      _0: match$2._0,
                      _1: match$2._1,
                      _2: s2
                    }
                  }
                }
              }
            };
    }
    
  } else if (typeof match$1._0 === "number") {
    var match$3 = match$1._1;
    if (typeof match$3 !== "number") {
      if (match$3.TAG === /* Left_small */6) {
        var match$4 = two(match$3._1);
        var p2 = snoc2(match$3._0, [
              match$4[0],
              match$4[1]
            ]);
        var p2$1 = snoc6(p2, six);
        return /* S */{
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */1,
                        _0: p2$1
                      }
                    }
                  }
                }
              };
      }
      var s2$1 = snoc6(match$3._2, six);
      return /* S */{
              _0: {
                TAG: /* T */0,
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_green */2,
                      _0: match$3._0,
                      _1: match$3._1,
                      _2: s2$1
                    }
                  }
                }
              }
            };
    }
    
  }
  var match$5 = match$1._0;
  if (typeof match$5 !== "number") {
    if (match$5.TAG === /* Left_yellow */8) {
      var s2$2 = snoc6(match$5._2, six);
      return /* S */{
              _0: {
                TAG: /* T */0,
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: {
                      TAG: /* Only_yellow */3,
                      _0: match$5._0,
                      _1: match$5._1,
                      _2: s2$2
                    },
                    _1: match$1._1
                  }
                }
              }
            };
    }
    var s2$3 = snoc6(match$5._2, six);
    return /* S */{
            _0: {
              TAG: /* T */0,
              _0: {
                TAG: /* Only_path */0,
                _0: /* Path */{
                  _0: {
                    TAG: /* Only_orange */4,
                    _0: match$5._0,
                    _1: match$5._1,
                    _2: s2$3
                  },
                  _1: match$1._1
                }
              }
            }
          };
  }
  
}

function semi_of_right(six, right) {
  var match = color_path(right);
  var match$1 = path_not_rev(right);
  if (match) {
    if (typeof match$1._0 === "number") {
      var match$2 = match$1._1;
      var p2 = cons6(six, match$2._0);
      return /* S */{
              _0: {
                TAG: /* T */0,
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_red */5,
                      _0: p2,
                      _1: match$2._1,
                      _2: match$2._2
                    }
                  }
                }
              }
            };
    }
    
  } else if (typeof match$1._0 === "number") {
    var match$3 = match$1._1;
    if (typeof match$3 !== "number") {
      if (match$3.TAG === /* Right_small */11) {
        var match$4 = two(match$3._0);
        var s2 = cons2([
              match$4[0],
              match$4[1]
            ], match$3._1);
        var s2$1 = cons6(six, s2);
        return /* S */{
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */1,
                        _0: s2$1
                      }
                    }
                  }
                }
              };
      }
      var p2$1 = cons6(six, match$3._0);
      return /* S */{
              _0: {
                TAG: /* T */0,
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_green */2,
                      _0: p2$1,
                      _1: match$3._1,
                      _2: match$3._2
                    }
                  }
                }
              }
            };
    }
    
  }
  var match$5 = match$1._0;
  if (typeof match$5 !== "number") {
    if (match$5.TAG === /* Right_yellow */13) {
      var p2$2 = cons6(six, match$5._0);
      return /* S */{
              _0: {
                TAG: /* T */0,
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: {
                      TAG: /* Only_yellow */3,
                      _0: p2$2,
                      _1: match$5._1,
                      _2: match$5._2
                    },
                    _1: match$1._1
                  }
                }
              }
            };
    }
    var p2$3 = cons6(six, match$5._0);
    return /* S */{
            _0: {
              TAG: /* T */0,
              _0: {
                TAG: /* Only_path */0,
                _0: /* Path */{
                  _0: {
                    TAG: /* Only_orange */4,
                    _0: p2$3,
                    _1: match$5._1,
                    _2: match$5._2
                  },
                  _1: match$1._1
                }
              }
            }
          };
  }
  
}

function uncons_green_left(left) {
  var match = path_not_rev(left);
  var match$1 = match._0;
  if (typeof match$1 === "number") {
    var match$2 = match._1;
    if (typeof match$2 !== "number") {
      if (match$2.TAG === /* Left_small */6) {
        var s1 = match$2._1;
        var match$3 = uncons(match$2._0);
        var p1 = has5(match$3[1]);
        var result;
        if (p1.TAG === /* Exact_4 */0) {
          var match$4 = p1._0;
          var match$5 = two(s1);
          result = {
            TAG: /* Exact_6 */0,
            _0: [
              match$4[0],
              match$4[1],
              match$4[2],
              match$4[3],
              match$5[0],
              match$5[1]
            ]
          };
        } else {
          result = {
            TAG: /* Any */1,
            _0: /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Left_small */6,
                _0: p1._0,
                _1: s1
              }
            }
          };
        }
        return [
                match$3[0],
                result
              ];
      }
      var match$6 = uncons(match$2._0);
      var match$7 = pref_left(match$2._1);
      var path_0 = {
        TAG: /* Left_yellow */8,
        _0: match$6[1],
        _1: match$7._0,
        _2: match$2._2
      };
      var path_1 = match$7._1;
      var path = /* Path */{
        _0: path_0,
        _1: path_1
      };
      return [
              match$6[0],
              {
                TAG: /* Any */1,
                _0: path
              }
            ];
    }
    
  } else {
    if (match$1.TAG === /* Left_yellow */8) {
      var match$8 = uncons(match$1._0);
      var match$9 = pref_right(match$1._1, match._1);
      var path_0$1 = {
        TAG: /* Left_orange */9,
        _0: match$8[1],
        _1: match$9._0,
        _2: match$1._2
      };
      var path_1$1 = match$9._1;
      var path$1 = /* Path */{
        _0: path_0$1,
        _1: path_1$1
      };
      return [
              match$8[0],
              {
                TAG: /* Any */1,
                _0: path$1
              }
            ];
    }
    var match$10 = uncons(match$1._0);
    var d1 = no_pref(match$1._1, match._1);
    var path_1$2 = {
      TAG: /* Left_red */10,
      _0: match$10[1],
      _1: d1,
      _2: match$1._2
    };
    var path$2 = /* Path */{
      _0: /* HOLE */0,
      _1: path_1$2
    };
    return [
            match$10[0],
            {
              TAG: /* Any */1,
              _0: path$2
            }
          ];
  }
}

function unsnoc_green_right(right) {
  var match = path_not_rev(right);
  var match$1 = match._0;
  if (typeof match$1 === "number") {
    var match$2 = match._1;
    if (typeof match$2 !== "number") {
      if (match$2.TAG === /* Right_small */11) {
        var p1 = match$2._0;
        var match$3 = unsnoc(match$2._1);
        var s1 = has5(match$3[0]);
        var result;
        if (s1.TAG === /* Exact_4 */0) {
          var match$4 = s1._0;
          var match$5 = two(p1);
          result = {
            TAG: /* Exact_6 */0,
            _0: [
              match$5[0],
              match$5[1],
              match$4[0],
              match$4[1],
              match$4[2],
              match$4[3]
            ]
          };
        } else {
          result = {
            TAG: /* Any */1,
            _0: /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Right_small */11,
                _0: p1,
                _1: s1._0
              }
            }
          };
        }
        return [
                result,
                match$3[1]
              ];
      }
      var match$6 = unsnoc(match$2._2);
      var match$7 = pref_left(match$2._1);
      var path_0 = {
        TAG: /* Right_yellow */13,
        _0: match$2._0,
        _1: match$7._0,
        _2: match$6[0]
      };
      var path_1 = match$7._1;
      var path = /* Path */{
        _0: path_0,
        _1: path_1
      };
      return [
              {
                TAG: /* Any */1,
                _0: path
              },
              match$6[1]
            ];
    }
    
  } else {
    if (match$1.TAG === /* Right_yellow */13) {
      var match$8 = unsnoc(match$1._2);
      var match$9 = pref_right(match$1._1, match._1);
      var path_0$1 = {
        TAG: /* Right_orange */14,
        _0: match$1._0,
        _1: match$9._0,
        _2: match$8[0]
      };
      var path_1$1 = match$9._1;
      var path$1 = /* Path */{
        _0: path_0$1,
        _1: path_1$1
      };
      return [
              {
                TAG: /* Any */1,
                _0: path$1
              },
              match$8[1]
            ];
    }
    var match$10 = unsnoc(match$1._2);
    var d1 = no_pref(match$1._1, match._1);
    var path_1$2 = {
      TAG: /* Right_red */15,
      _0: match$1._0,
      _1: d1,
      _2: match$10[0]
    };
    var path$2 = /* Path */{
      _0: /* HOLE */0,
      _1: path_1$2
    };
    return [
            {
              TAG: /* Any */1,
              _0: path$2
            },
            match$10[1]
          ];
  }
}

function uncons_green(path) {
  if (path.TAG === /* Only_path */0) {
    var match = path_not_rev(path._0);
    var match$1 = match._0;
    if (typeof match$1 === "number") {
      var p1 = match._1;
      if (typeof p1 !== "number") {
        if (p1.TAG === /* Only_prefix */1) {
          var match$2 = uncons(p1._0);
          var p1$1 = has1(match$2[1]);
          var s = p1$1 ? /* S */({
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */1,
                        _0: p1$1._0
                      }
                    }
                  }
                }
              }) : /* S */({
                _0: /* Void */0
              });
          return [
                  match$2[0],
                  s
                ];
        }
        var match$3 = uncons(p1._0);
        var match$4 = pref_left(p1._1);
        var only_0 = {
          TAG: /* Only_yellow */3,
          _0: match$3[1],
          _1: match$4._0,
          _2: p1._2
        };
        var only_1 = match$4._1;
        var only = /* Path */{
          _0: only_0,
          _1: only_1
        };
        return [
                match$3[0],
                /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only
                    }
                  }
                }
              ];
      }
      
    } else {
      if (match$1.TAG === /* Only_yellow */3) {
        var match$5 = uncons(match$1._0);
        var match$6 = pref_right(match$1._1, match._1);
        var only_0$1 = {
          TAG: /* Only_orange */4,
          _0: match$5[1],
          _1: match$6._0,
          _2: match$1._2
        };
        var only_1$1 = match$6._1;
        var only$1 = /* Path */{
          _0: only_0$1,
          _1: only_1$1
        };
        return [
                match$5[0],
                /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only$1
                    }
                  }
                }
              ];
      }
      var match$7 = uncons(match$1._0);
      var d1 = no_pref(match$1._1, match._1);
      var only_1$2 = {
        TAG: /* Only_red */5,
        _0: match$7[1],
        _1: d1,
        _2: match$1._2
      };
      var only$2 = /* Path */{
        _0: /* HOLE */0,
        _1: only_1$2
      };
      return [
              match$7[0],
              /* S */{
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: only$2
                  }
                }
              }
            ];
    }
  } else {
    var right = path._1;
    var match$8 = uncons_green_left(path._0);
    var result = match$8[1];
    var tmp;
    tmp = result.TAG === /* Exact_6 */0 ? semi_of_right(result._0, right) : /* S */({
          _0: {
            TAG: /* T */0,
            _0: {
              TAG: /* Pair_green */1,
              _0: result._0,
              _1: right
            }
          }
        });
    return [
            match$8[0],
            tmp
          ];
  }
}

function unsnoc_green(path) {
  if (path.TAG === /* Only_path */0) {
    var match = path_not_rev(path._0);
    var match$1 = match._0;
    if (typeof match$1 === "number") {
      var p1 = match._1;
      if (typeof p1 !== "number") {
        if (p1.TAG === /* Only_prefix */1) {
          var match$2 = unsnoc(p1._0);
          var p1$1 = has1(match$2[0]);
          var s = p1$1 ? /* S */({
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */1,
                        _0: p1$1._0
                      }
                    }
                  }
                }
              }) : /* S */({
                _0: /* Void */0
              });
          return [
                  s,
                  match$2[1]
                ];
        }
        var match$3 = unsnoc(p1._2);
        var match$4 = pref_left(p1._1);
        var only_0 = {
          TAG: /* Only_yellow */3,
          _0: p1._0,
          _1: match$4._0,
          _2: match$3[0]
        };
        var only_1 = match$4._1;
        var only = /* Path */{
          _0: only_0,
          _1: only_1
        };
        return [
                /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only
                    }
                  }
                },
                match$3[1]
              ];
      }
      
    } else {
      if (match$1.TAG === /* Only_yellow */3) {
        var match$5 = unsnoc(match$1._2);
        var match$6 = pref_right(match$1._1, match._1);
        var only_0$1 = {
          TAG: /* Only_orange */4,
          _0: match$1._0,
          _1: match$6._0,
          _2: match$5[0]
        };
        var only_1$1 = match$6._1;
        var only$1 = /* Path */{
          _0: only_0$1,
          _1: only_1$1
        };
        return [
                /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only$1
                    }
                  }
                },
                match$5[1]
              ];
      }
      var match$7 = unsnoc(match$1._2);
      var d1 = no_pref(match$1._1, match._1);
      var only_1$2 = {
        TAG: /* Only_red */5,
        _0: match$1._0,
        _1: d1,
        _2: match$7[0]
      };
      var only$2 = /* Path */{
        _0: /* HOLE */0,
        _1: only_1$2
      };
      return [
              /* S */{
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: only$2
                  }
                }
              },
              match$7[1]
            ];
    }
  } else {
    var left = path._0;
    var match$8 = unsnoc_green_right(path._1);
    var result = match$8[0];
    var result$1;
    result$1 = result.TAG === /* Exact_6 */0 ? semi_of_left(left, result._0) : /* S */({
          _0: {
            TAG: /* T */0,
            _0: {
              TAG: /* Pair_green */1,
              _0: left,
              _1: result._0
            }
          }
        });
    return [
            result$1,
            match$8[1]
          ];
  }
}

function stored_elt(x) {
  if (x.TAG === /* L2R */0) {
    return x._0;
  }
  var p = x._0;
  if (p.TAG === /* Stored_prefix */0) {
    return {
            TAG: /* Stored_prefix */0,
            _0: Dequeue_internal.rev(p._0)
          };
  } else {
    return {
            TAG: /* Stored */1,
            _0: Dequeue_internal.rev(p._2),
            _1: st_rev(p._1),
            _2: Dequeue_internal.rev(p._0)
          };
  }
}

function uncons_stored(d1) {
  var match = uncons_green(d1);
  var d1$1 = match[1];
  var p2 = stored_elt(match[0]);
  if (p2.TAG === /* Stored_prefix */0) {
    return /* Unstored */{
            _0: p2._0,
            _1: d1$1
          };
  }
  var s2 = {
    TAG: /* Stored_prefix */0,
    _0: p2._2
  };
  var d1$2 = cons_semi({
        TAG: /* L2R */0,
        _0: s2
      }, d1$1);
  var d1$3 = concat_semi(/* S */{
        _0: p2._1
      }, d1$2);
  return /* Unstored */{
          _0: p2._0,
          _1: d1$3
        };
}

function unsnoc_stored(d1) {
  var match = unsnoc_green(d1);
  var d1$1 = match[0];
  var p2 = stored_elt(match[1]);
  if (p2.TAG === /* Stored_prefix */0) {
    return /* Unstored */{
            _0: p2._0,
            _1: d1$1
          };
  }
  var p2$1 = {
    TAG: /* Stored_prefix */0,
    _0: p2._0
  };
  var d1$2 = snoc_semi(d1$1, {
        TAG: /* L2R */0,
        _0: p2$1
      });
  var d1$3 = concat_semi(d1$2, /* S */{
        _0: p2._1
      });
  return /* Unstored */{
          _0: p2._2,
          _1: d1$3
        };
}

function unsandwich_green(path) {
  if (path.TAG === /* Only_path */0) {
    var match = path_not_rev(path._0);
    var match$1 = match._0;
    if (typeof match$1 === "number") {
      var p1 = match._1;
      if (typeof p1 !== "number") {
        if (p1.TAG === /* Only_prefix */1) {
          var match$2 = uncons(p1._0);
          var x = match$2[0];
          var p1$1 = has1(match$2[1]);
          if (!p1$1) {
            return {
                    TAG: /* Alone */0,
                    _0: x
                  };
          }
          var match$3 = unsnoc(p1$1._0);
          var p1$2 = has1(match$3[0]);
          var d1 = p1$2 ? /* S */({
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */1,
                        _0: p1$2._0
                      }
                    }
                  }
                }
              }) : /* S */({
                _0: /* Void */0
              });
          return {
                  TAG: /* Sandwich */1,
                  _0: x,
                  _1: d1,
                  _2: match$3[1]
                };
        }
        var match$4 = uncons(p1._0);
        var match$5 = unsnoc(p1._2);
        var match$6 = pref_left(p1._1);
        var only_0 = {
          TAG: /* Only_yellow */3,
          _0: match$4[1],
          _1: match$6._0,
          _2: match$5[0]
        };
        var only_1 = match$6._1;
        var only = /* Path */{
          _0: only_0,
          _1: only_1
        };
        return {
                TAG: /* Sandwich */1,
                _0: match$4[0],
                _1: /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only
                    }
                  }
                },
                _2: match$5[1]
              };
      }
      
    } else {
      if (match$1.TAG === /* Only_yellow */3) {
        var match$7 = uncons(match$1._0);
        var match$8 = unsnoc(match$1._2);
        var match$9 = pref_right(match$1._1, match._1);
        var only_0$1 = {
          TAG: /* Only_orange */4,
          _0: match$7[1],
          _1: match$9._0,
          _2: match$8[0]
        };
        var only_1$1 = match$9._1;
        var only$1 = /* Path */{
          _0: only_0$1,
          _1: only_1$1
        };
        return {
                TAG: /* Sandwich */1,
                _0: match$7[0],
                _1: /* S */{
                  _0: {
                    TAG: /* T */0,
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only$1
                    }
                  }
                },
                _2: match$8[1]
              };
      }
      var match$10 = uncons(match$1._0);
      var match$11 = unsnoc(match$1._2);
      var d1$1 = no_pref(match$1._1, match._1);
      var only_1$2 = {
        TAG: /* Only_red */5,
        _0: match$10[1],
        _1: d1$1,
        _2: match$11[0]
      };
      var only$2 = /* Path */{
        _0: /* HOLE */0,
        _1: only_1$2
      };
      return {
              TAG: /* Sandwich */1,
              _0: match$10[0],
              _1: /* S */{
                _0: {
                  TAG: /* T */0,
                  _0: {
                    TAG: /* Only_path */0,
                    _0: only$2
                  }
                }
              },
              _2: match$11[1]
            };
    }
  } else {
    var match$12 = uncons_green_left(path._0);
    var left = match$12[1];
    var match$13 = unsnoc_green_right(path._1);
    var right = match$13[0];
    var d1$2;
    if (left.TAG === /* Exact_6 */0) {
      var lst = left._0;
      if (right.TAG === /* Exact_6 */0) {
        var buf = cons6(right._0, Dequeue_internal.empty);
        var buf$1 = cons6(lst, buf);
        d1$2 = /* S */{
          _0: {
            TAG: /* T */0,
            _0: {
              TAG: /* Only_path */0,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Only_prefix */1,
                  _0: buf$1
                }
              }
            }
          }
        };
      } else {
        d1$2 = semi_of_right(lst, right._0);
      }
    } else {
      var left$1 = left._0;
      d1$2 = right.TAG === /* Exact_6 */0 ? semi_of_left(left$1, right._0) : /* S */({
            _0: {
              TAG: /* T */0,
              _0: {
                TAG: /* Pair_green */1,
                _0: left$1,
                _1: right._0
              }
            }
          });
    }
    return {
            TAG: /* Sandwich */1,
            _0: match$12[0],
            _1: d1$2,
            _2: match$13[1]
          };
  }
}

function unsandwich_stored(d1) {
  var stored = unsandwich_green(d1);
  if (stored.TAG === /* Alone */0) {
    var x = stored_elt(stored._0);
    if (x.TAG === /* Stored_prefix */0) {
      return {
              TAG: /* Unstored_alone */0,
              _0: x._0
            };
    } else {
      return {
              TAG: /* Unstored_sandwich */1,
              _0: x._0,
              _1: /* S */{
                _0: x._1
              },
              _2: x._2
            };
    }
  }
  var d1$1 = stored._1;
  var match = stored_elt(stored._0);
  var match$1 = stored_elt(stored._2);
  if (match.TAG === /* Stored_prefix */0) {
    var p2 = match._0;
    if (match$1.TAG === /* Stored_prefix */0) {
      return {
              TAG: /* Unstored_sandwich */1,
              _0: p2,
              _1: d1$1,
              _2: match$1._0
            };
    }
    var d1$2 = snoc_semi(d1$1, {
          TAG: /* L2R */0,
          _0: {
            TAG: /* Stored_prefix */0,
            _0: match$1._0
          }
        });
    var d1$3 = concat_semi(d1$2, /* S */{
          _0: match$1._1
        });
    return {
            TAG: /* Unstored_sandwich */1,
            _0: p2,
            _1: d1$3,
            _2: match$1._2
          };
  }
  var s2 = match._2;
  var d2 = match._1;
  var p2$1 = match._0;
  if (match$1.TAG === /* Stored_prefix */0) {
    var d1$4 = cons_semi({
          TAG: /* L2R */0,
          _0: {
            TAG: /* Stored_prefix */0,
            _0: s2
          }
        }, d1$1);
    var d1$5 = concat_semi(/* S */{
          _0: d2
        }, d1$4);
    return {
            TAG: /* Unstored_sandwich */1,
            _0: p2$1,
            _1: d1$5,
            _2: match$1._0
          };
  }
  var d1$6 = cons_semi({
        TAG: /* L2R */0,
        _0: {
          TAG: /* Stored_prefix */0,
          _0: s2
        }
      }, d1$1);
  var d1$7 = snoc_semi(d1$6, {
        TAG: /* L2R */0,
        _0: {
          TAG: /* Stored_prefix */0,
          _0: match$1._0
        }
      });
  var d1$8 = concat_semi(/* S */{
        _0: d2
      }, d1$7);
  var d1$9 = concat_semi(d1$8, /* S */{
        _0: match$1._1
      });
  return {
          TAG: /* Unstored_sandwich */1,
          _0: p2$1,
          _1: d1$9,
          _2: match$1._2
        };
}

function only_small(p2, s2) {
  var match = has3p8(s2);
  if (match.TAG === /* Less_than_11 */0) {
    var p2$1 = vector_fold_left(snoc, snoc8(p2, match._0), match._1);
    return {
            TAG: /* Only_prefix */1,
            _0: p2$1
          };
  }
  var stored = {
    TAG: /* Stored_prefix */0,
    _0: triple(match._0, match._1, match._2)
  };
  var d1 = only_single({
        TAG: /* L2R */0,
        _0: stored
      });
  return {
          TAG: /* Only_green */2,
          _0: p2,
          _1: d1,
          _2: match._3
        };
}

function only_green(p2, d2, s2) {
  var d2$1 = d2._0;
  if (typeof d2$1 === "number") {
    return only_small(p2, s2);
  } else if (d2$1.TAG === /* T */0) {
    return {
            TAG: /* Only_green */2,
            _0: p2,
            _1: d2$1._0,
            _2: s2
          };
  } else {
    return {
            TAG: /* Only_green */2,
            _0: p2,
            _1: deque_rev(d2$1._0),
            _2: s2
          };
  }
}

function ensure_green(t) {
  var t$1 = triple_not_rev(t);
  var match = color(t$1);
  if (!match) {
    return t$1;
  }
  if (typeof t$1 !== "number") {
    switch (t$1.TAG | 0) {
      case /* Only_red */5 :
          var d1 = t$1._1;
          var match$1 = has8(t$1._0);
          var match$2 = has8(t$1._2);
          if (match$1.TAG === /* Less_than_8 */0) {
            var p1_lst = match$1._0;
            if (match$2.TAG === /* Less_than_8 */0) {
              var s1_lst = match$2._0;
              var center = unsandwich_stored(d1);
              if (center.TAG === /* Unstored_alone */0) {
                var center$1 = cons_5_vector(p1_lst, center._0);
                var center$2 = snoc_5_vector(center$1, s1_lst);
                return {
                        TAG: /* Only_prefix */1,
                        _0: center$2
                      };
              }
              var p2 = cons_5_vector(p1_lst, center._0);
              var s2 = snoc_5_vector(center._2, s1_lst);
              return only_green(p2, center._1, s2);
            }
            var match$3 = uncons_stored(d1);
            var p2$1 = cons_5_vector(p1_lst, match$3._0);
            return only_green(p2$1, match$3._1, match$2._0);
          }
          var p1 = match$1._0;
          if (match$2.TAG !== /* Less_than_8 */0) {
            return {
                    TAG: /* Only_green */2,
                    _0: p1,
                    _1: d1,
                    _2: match$2._0
                  };
          }
          var match$4 = unsnoc_stored(d1);
          var s2$1 = snoc_5_vector(match$4._0, match$2._0);
          return only_green(p1, match$4._1, s2$1);
      case /* Left_red */10 :
          var s1 = t$1._2;
          var d1$1 = t$1._1;
          var p1$1 = has8(t$1._0);
          if (p1$1.TAG !== /* Less_than_8 */0) {
            return {
                    TAG: /* Left_green */7,
                    _0: p1$1._0,
                    _1: d1$1,
                    _2: s1
                  };
          }
          var match$5 = uncons_stored(d1$1);
          var d1$2 = match$5._1._0;
          var p2$2 = cons_5_vector(p1$1._0, match$5._0);
          if (typeof d1$2 === "number") {
            return {
                    TAG: /* Left_small */6,
                    _0: p2$2,
                    _1: s1
                  };
          } else if (d1$2.TAG === /* T */0) {
            return {
                    TAG: /* Left_green */7,
                    _0: p2$2,
                    _1: d1$2._0,
                    _2: s1
                  };
          } else {
            return {
                    TAG: /* Left_green */7,
                    _0: p2$2,
                    _1: deque_rev(d1$2._0),
                    _2: s1
                  };
          }
      case /* Right_red */15 :
          var d1$3 = t$1._1;
          var p1$2 = t$1._0;
          var s1$1 = has8(t$1._2);
          if (s1$1.TAG !== /* Less_than_8 */0) {
            return {
                    TAG: /* Right_green */12,
                    _0: p1$2,
                    _1: d1$3,
                    _2: s1$1._0
                  };
          }
          var match$6 = unsnoc_stored(d1$3);
          var d1$4 = match$6._1._0;
          var s2$2 = snoc_5_vector(match$6._0, s1$1._0);
          if (typeof d1$4 === "number") {
            return {
                    TAG: /* Right_small */11,
                    _0: p1$2,
                    _1: s2$2
                  };
          } else if (d1$4.TAG === /* T */0) {
            return {
                    TAG: /* Right_green */12,
                    _0: p1$2,
                    _1: d1$4._0,
                    _2: s2$2
                  };
          } else {
            return {
                    TAG: /* Right_green */12,
                    _0: p1$2,
                    _1: deque_rev(d1$4._0),
                    _2: s2$2
                  };
          }
      
    }
  }
  
}

function ensure_green_path(param) {
  return /* Path */{
          _0: param._0,
          _1: ensure_green(param._1)
        };
}

function ensure_green_deque(p) {
  switch (p.TAG | 0) {
    case /* Only_path */0 :
        return {
                TAG: /* Only_path */0,
                _0: ensure_green_path(p._0)
              };
    case /* Pair_green */1 :
        return {
                TAG: /* Pair_red */2,
                _0: ensure_green_path(p._0),
                _1: ensure_green_path(p._1)
              };
    case /* Pair_red */2 :
        return {
                TAG: /* Pair_red */2,
                _0: p._0,
                _1: p._1
              };
    
  }
}

function regular_of_semi(param) {
  var deq = param._0;
  if (typeof deq === "number") {
    return /* Regular */{
            _0: /* Void */0
          };
  } else if (deq.TAG === /* T */0) {
    return /* Regular */{
            _0: {
              TAG: /* T */0,
              _0: ensure_green_deque(deq._0)
            }
          };
  } else {
    return /* Regular */{
            _0: {
              TAG: /* Rev */1,
              _0: ensure_green_deque(deq._0)
            }
          };
  }
}

function rev_regular_of_semi(param) {
  var deq = param._0;
  if (typeof deq === "number") {
    return /* Regular */{
            _0: /* Void */0
          };
  } else if (deq.TAG === /* T */0) {
    return /* Regular */{
            _0: {
              TAG: /* Rev */1,
              _0: ensure_green_deque(deq._0)
            }
          };
  } else {
    return /* Regular */{
            _0: {
              TAG: /* T */0,
              _0: ensure_green_deque(deq._0)
            }
          };
  }
}

function unelt(x) {
  return x._0;
}

function uncons$1(t) {
  var t$1 = t._0;
  if (typeof t$1 === "number") {
    return ;
  }
  if (t$1.TAG === /* T */0) {
    var match = uncons_green(t$1._0);
    var reg = regular_of_semi(match[1]);
    return [
            match[0]._0,
            reg
          ];
  }
  var match$1 = unsnoc_green(t$1._0);
  var reg$1 = rev_regular_of_semi(match$1[0]);
  return [
          match$1[1]._0,
          reg$1
        ];
}

function unsnoc$1(t) {
  var t$1 = t._0;
  if (typeof t$1 === "number") {
    return ;
  }
  if (t$1.TAG === /* T */0) {
    var match = unsnoc_green(t$1._0);
    return [
            regular_of_semi(match[0]),
            match[1]._0
          ];
  }
  var match$1 = uncons_green(t$1._0);
  return [
          rev_regular_of_semi(match$1[1]),
          match$1[0]._0
        ];
}

function rev$1(t) {
  var t$1 = t._0;
  if (typeof t$1 === "number") {
    return /* Regular */{
            _0: /* Void */0
          };
  } else if (t$1.TAG === /* T */0) {
    return /* Regular */{
            _0: {
              TAG: /* Rev */1,
              _0: t$1._0
            }
          };
  } else {
    return /* Regular */{
            _0: {
              TAG: /* T */0,
              _0: t$1._0
            }
          };
  }
}

function cons$2(x, t) {
  return cons$1({
              TAG: /* L2R */0,
              _0: x
            }, t);
}

function snoc$2(t, x) {
  return snoc$1(t, {
              TAG: /* L2R */0,
              _0: x
            });
}

var Deq;

var empty = /* Regular */{
  _0: /* Void */0
};

export {
  Deq ,
  vector_fold_right ,
  vector_fold_left ,
  $$Buffer ,
  empty ,
  is_empty ,
  triple_rev ,
  path_rev ,
  deque_rev ,
  not_empty_rev ,
  st_rev ,
  triple_force_rev ,
  triple_not_rev ,
  cons_only_triple ,
  snoc_only_triple ,
  is_hole ,
  cons_only_path ,
  snoc_only_path ,
  cons_left_triple ,
  snoc_right_triple ,
  cons_left_path ,
  snoc_right_path ,
  cons_deque ,
  snoc_deque ,
  single_triple ,
  only_single ,
  single ,
  cons_t ,
  snoc_t ,
  cons_semi ,
  snoc_semi ,
  cons_vector$1 as cons_vector,
  snoc_vector$1 as snoc_vector,
  cons_semi_vector ,
  snoc_semi_vector ,
  color ,
  color_path ,
  color_deque ,
  color_st ,
  pref_left ,
  pref_right ,
  no_pref ,
  make_child ,
  cons_child ,
  snoc_child ,
  stored_left ,
  stored_right ,
  extract_stored_left ,
  extract_stored_right ,
  path_not_rev ,
  left_of_pair ,
  right_of_pair ,
  left_of_only ,
  right_of_only ,
  make_left ,
  make_right ,
  concat_semi ,
  concat ,
  semi_of_left ,
  semi_of_right ,
  uncons_green_left ,
  unsnoc_green_right ,
  uncons_green ,
  unsnoc_green ,
  stored_elt ,
  uncons_stored ,
  unsnoc_stored ,
  unsandwich_green ,
  unsandwich_stored ,
  only_small ,
  only_green ,
  ensure_green ,
  ensure_green_path ,
  ensure_green_deque ,
  regular_of_semi ,
  rev_regular_of_semi ,
  unelt ,
  uncons$1 as uncons,
  unsnoc$1 as unsnoc,
  rev$1 as rev,
  cons$2 as cons,
  snoc$2 as snoc,
  
}
/* No side effect */
