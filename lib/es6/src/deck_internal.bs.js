// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Dequeue_internal$ReasonDeque from "./dequeue_internal.bs.js";

function vector_fold_right(fn, v, z) {
  if (typeof v === "number") {
    return z;
  }
  switch (v.TAG | 0) {
    case /* V1 */0 :
        return Curry._2(fn, v._0, z);
    case /* V2 */1 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, z));
    case /* V3 */2 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, z)));
    case /* V4 */3 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, Curry._2(fn, v._3, z))));
    case /* V5 */4 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, Curry._2(fn, v._3, Curry._2(fn, v._4, z)))));
    case /* V6 */5 :
        return Curry._2(fn, v._0, Curry._2(fn, v._1, Curry._2(fn, v._2, Curry._2(fn, v._3, Curry._2(fn, v._4, Curry._2(fn, v._5, z))))));
    
  }
}

function vector_fold_left(fn, z, v) {
  if (typeof v === "number") {
    return z;
  }
  switch (v.TAG | 0) {
    case /* V1 */0 :
        return Curry._2(fn, z, v._0);
    case /* V2 */1 :
        return Curry._2(fn, Curry._2(fn, z, v._0), v._1);
    case /* V3 */2 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2);
    case /* V4 */3 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2), v._3);
    case /* V5 */4 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2), v._3), v._4);
    case /* V6 */5 :
        return Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, Curry._2(fn, z, v._0), v._1), v._2), v._3), v._4), v._5);
    
  }
}

var cons = Dequeue_internal$ReasonDeque.cons;

var snoc = Dequeue_internal$ReasonDeque.snoc;

function uncons(t) {
  var match = Dequeue_internal$ReasonDeque.uncons(t);
  if (match !== undefined) {
    return [
            match[0],
            match[1]
          ];
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "deck_internal.ml",
          142,
          14
        ],
        Error: new Error()
      };
}

function unsnoc(t) {
  var match = Dequeue_internal$ReasonDeque.unsnoc(t);
  if (match !== undefined) {
    return [
            match[0],
            match[1]
          ];
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "deck_internal.ml",
          145,
          14
        ],
        Error: new Error()
      };
}

function single(x) {
  return Dequeue_internal$ReasonDeque.cons(x, Dequeue_internal$ReasonDeque.empty);
}

function pair(x, y) {
  return Dequeue_internal$ReasonDeque.cons(x, Dequeue_internal$ReasonDeque.cons(y, Dequeue_internal$ReasonDeque.empty));
}

function triple(x, y, z) {
  return Dequeue_internal$ReasonDeque.cons(x, Dequeue_internal$ReasonDeque.cons(y, Dequeue_internal$ReasonDeque.cons(z, Dequeue_internal$ReasonDeque.empty)));
}

function uncons2(t) {
  var match = uncons(t);
  var match$1 = uncons(match[1]);
  return [
          match[0],
          match$1[0],
          match$1[1]
        ];
}

function unsnoc2(t) {
  var match = unsnoc(t);
  var match$1 = unsnoc(match[0]);
  return [
          match$1[0],
          match$1[1],
          match[1]
        ];
}

function two(t) {
  var match = uncons2(t);
  if (!Dequeue_internal$ReasonDeque.is_empty(match[2])) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "deck_internal.ml",
            164,
            4
          ],
          Error: new Error()
        };
  }
  return [
          match[0],
          match[1]
        ];
}

function has1(t) {
  if (Dequeue_internal$ReasonDeque.is_empty(t)) {
    return /* Exact_0 */0;
  } else {
    return /* Lte1 */{
            _0: t
          };
  }
}

function to_dequeue(t) {
  return t;
}

function of_dequeue(d) {
  if (Dequeue_internal$ReasonDeque.is_empty(d)) {
    return /* Exact_0 */0;
  } else {
    return /* Lte1 */{
            _0: d
          };
  }
}

function snoc2(t, param) {
  return Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(t, param[0]), param[1]);
}

function cons2(param, t) {
  return Dequeue_internal$ReasonDeque.cons(param[0], Dequeue_internal$ReasonDeque.cons(param[1], t));
}

function cons6(param, t) {
  return Dequeue_internal$ReasonDeque.cons(param[0], Dequeue_internal$ReasonDeque.cons(param[1], Dequeue_internal$ReasonDeque.cons(param[2], Dequeue_internal$ReasonDeque.cons(param[3], Dequeue_internal$ReasonDeque.cons(param[4], Dequeue_internal$ReasonDeque.cons(param[5], t))))));
}

function snoc6(t, param) {
  return Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(t, param[0]), param[1]), param[2]), param[3]), param[4]), param[5]);
}

function uncons3(t) {
  var match = Dequeue_internal$ReasonDeque.uncons(t);
  if (match === undefined) {
    return {
            TAG: /* Not_enough */0,
            _0: /* V0 */0
          };
  }
  var x = match[0];
  var match$1 = Dequeue_internal$ReasonDeque.uncons(match[1]);
  if (match$1 === undefined) {
    return {
            TAG: /* Not_enough */0,
            _0: {
              TAG: /* V1 */0,
              _0: x
            }
          };
  }
  var y = match$1[0];
  var match$2 = Dequeue_internal$ReasonDeque.uncons(match$1[1]);
  if (match$2 !== undefined) {
    return {
            TAG: /* Enough */1,
            _0: {
              TAG: /* V3 */2,
              _0: x,
              _1: y,
              _2: match$2[0]
            },
            _1: match$2[1]
          };
  } else {
    return {
            TAG: /* Not_enough */0,
            _0: {
              TAG: /* V2 */1,
              _0: x,
              _1: y
            }
          };
  }
}

function uncons5(t) {
  var match = uncons2(t);
  var match$1 = uncons2(match[2]);
  var match$2 = uncons(match$1[2]);
  return [
          [
            match[0],
            match[1],
            match$1[0],
            match$1[1],
            match$2[0]
          ],
          match$2[1]
        ];
}

function has8(buffer) {
  var match = uncons5(buffer);
  var vec = uncons3(match[1]);
  if (vec.TAG === /* Not_enough */0) {
    return {
            TAG: /* Less_than_8 */0,
            _0: [
              match[0],
              vec._0
            ]
          };
  } else {
    return {
            TAG: /* At_least_8 */1,
            _0: buffer
          };
  }
}

function has5(buffer) {
  var match = uncons2(buffer);
  var match$1 = uncons2(match[2]);
  var match$2 = has1(match$1[2]);
  if (match$2) {
    return {
            TAG: /* At_least_5 */1,
            _0: buffer
          };
  } else {
    return {
            TAG: /* Exact_4 */0,
            _0: [
              match[0],
              match[1],
              match$1[0],
              match$1[1]
            ]
          };
  }
}

function cons_vector(v, t) {
  return vector_fold_right(Dequeue_internal$ReasonDeque.cons, v, t);
}

function snoc_vector(t, v) {
  return vector_fold_left(Dequeue_internal$ReasonDeque.snoc, t, v);
}

function has5p2(t) {
  var match = unsnoc(t);
  var a = match[1];
  var match$1 = Dequeue_internal$ReasonDeque.unsnoc(match[0]);
  if (match$1 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V1 */0,
              _0: a
            }
          };
  }
  var t5 = match$1[0];
  var b = match$1[1];
  var match$2 = Dequeue_internal$ReasonDeque.unsnoc(t5);
  if (match$2 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V2 */1,
              _0: b,
              _1: a
            }
          };
  }
  var c = match$2[1];
  var match$3 = Dequeue_internal$ReasonDeque.unsnoc(match$2[0]);
  if (match$3 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V3 */2,
              _0: c,
              _1: b,
              _2: a
            }
          };
  }
  var d = match$3[1];
  var match$4 = Dequeue_internal$ReasonDeque.unsnoc(match$3[0]);
  if (match$4 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V4 */3,
              _0: d,
              _1: c,
              _2: b,
              _3: a
            }
          };
  }
  var e = match$4[1];
  var match$5 = Dequeue_internal$ReasonDeque.unsnoc(match$4[0]);
  if (match$5 === undefined) {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V5 */4,
              _0: e,
              _1: d,
              _2: c,
              _3: b,
              _4: a
            }
          };
  }
  var match$6 = Dequeue_internal$ReasonDeque.unsnoc(match$5[0]);
  if (match$6 !== undefined) {
    return {
            TAG: /* At_least_5p2 */1,
            _0: t5,
            _1: b,
            _2: a
          };
  } else {
    return {
            TAG: /* Less_than_5p2 */0,
            _0: {
              TAG: /* V6 */5,
              _0: match$5[1],
              _1: e,
              _2: d,
              _3: c,
              _4: b,
              _5: a
            }
          };
  }
}

function has2p5(t) {
  var match = uncons(t);
  var a = match[0];
  var match$1 = Dequeue_internal$ReasonDeque.uncons(match[1]);
  if (match$1 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V1 */0,
              _0: a
            }
          };
  }
  var t5 = match$1[1];
  var b = match$1[0];
  var match$2 = Dequeue_internal$ReasonDeque.uncons(t5);
  if (match$2 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V2 */1,
              _0: a,
              _1: b
            }
          };
  }
  var c = match$2[0];
  var match$3 = Dequeue_internal$ReasonDeque.uncons(match$2[1]);
  if (match$3 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V3 */2,
              _0: a,
              _1: b,
              _2: c
            }
          };
  }
  var d = match$3[0];
  var match$4 = Dequeue_internal$ReasonDeque.uncons(match$3[1]);
  if (match$4 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V4 */3,
              _0: a,
              _1: b,
              _2: c,
              _3: d
            }
          };
  }
  var e = match$4[0];
  var match$5 = Dequeue_internal$ReasonDeque.uncons(match$4[1]);
  if (match$5 === undefined) {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V5 */4,
              _0: a,
              _1: b,
              _2: c,
              _3: d,
              _4: e
            }
          };
  }
  var match$6 = Dequeue_internal$ReasonDeque.uncons(match$5[1]);
  if (match$6 !== undefined) {
    return {
            TAG: /* At_least_2p5 */1,
            _0: a,
            _1: b,
            _2: t5
          };
  } else {
    return {
            TAG: /* Less_than_2p5 */0,
            _0: {
              TAG: /* V6 */5,
              _0: a,
              _1: b,
              _2: c,
              _3: d,
              _4: e,
              _5: match$5[0]
            }
          };
  }
}

function has3p8(t) {
  var match = uncons2(t);
  var b = match[1];
  var a = match[0];
  var match$1 = uncons(match[2]);
  var t8 = match$1[1];
  var c = match$1[0];
  var match$2 = uncons2(t8);
  var match$3 = uncons2(match$2[2]);
  var match$4 = uncons(match$3[2]);
  var vec = uncons3(match$4[1]);
  if (vec.TAG === /* Not_enough */0) {
    return {
            TAG: /* Less_than_11 */0,
            _0: [
              a,
              b,
              c,
              match$2[0],
              match$2[1],
              match$3[0],
              match$3[1],
              match$4[0]
            ],
            _1: vec._0
          };
  } else {
    return {
            TAG: /* At_least_11 */1,
            _0: a,
            _1: b,
            _2: c,
            _3: t8
          };
  }
}

function snoc5(t, param) {
  return Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(t, param[0]), param[1]), param[2]), param[3]), param[4]);
}

function cons_5_vector(param, t) {
  var param$1 = param[0];
  var t$1 = vector_fold_right(Dequeue_internal$ReasonDeque.cons, param[1], t);
  return Dequeue_internal$ReasonDeque.cons(param$1[0], Dequeue_internal$ReasonDeque.cons(param$1[1], Dequeue_internal$ReasonDeque.cons(param$1[2], Dequeue_internal$ReasonDeque.cons(param$1[3], Dequeue_internal$ReasonDeque.cons(param$1[4], t$1)))));
}

function snoc_5_vector(t, param) {
  var t$1 = snoc5(t, param[0]);
  return vector_fold_left(Dequeue_internal$ReasonDeque.snoc, t$1, param[1]);
}

function snoc8(t, param) {
  return Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(Dequeue_internal$ReasonDeque.snoc(t, param[0]), param[1]), param[2]), param[3]), param[4]), param[5]), param[6]), param[7]);
}

var $$Buffer = {
  empty: Dequeue_internal$ReasonDeque.empty,
  cons: cons,
  snoc: snoc,
  uncons: uncons,
  unsnoc: unsnoc,
  uncons2: uncons2,
  unsnoc2: unsnoc2,
  single: single,
  pair: pair,
  triple: triple,
  two: two,
  cons2: cons2,
  snoc2: snoc2,
  cons_5_vector: cons_5_vector,
  snoc_5_vector: snoc_5_vector,
  cons6: cons6,
  snoc6: snoc6,
  snoc8: snoc8,
  cons_vector: cons_vector,
  snoc_vector: snoc_vector,
  has1: has1,
  to_dequeue: to_dequeue,
  of_dequeue: of_dequeue,
  has5: has5,
  has5p2: has5p2,
  has2p5: has2p5,
  has8: has8,
  has3p8: has3p8
};

function is_empty(param) {
  if (param._0) {
    return false;
  } else {
    return true;
  }
}

function cons_only_triple(x, triple) {
  if (typeof triple !== "number") {
    switch (triple.TAG | 0) {
      case /* Only_prefix */0 :
          return {
                  TAG: /* Only_prefix */0,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0)
                };
      case /* Only_green */1 :
          return {
                  TAG: /* Only_green */1,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      case /* Only_yellow */2 :
          return {
                  TAG: /* Only_yellow */2,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      case /* Only_orange */3 :
          return {
                  TAG: /* Only_orange */3,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      case /* Only_red */4 :
          return {
                  TAG: /* Only_red */4,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      
    }
  }
  
}

function snoc_only_triple(triple, x) {
  if (typeof triple !== "number") {
    switch (triple.TAG | 0) {
      case /* Only_prefix */0 :
          return {
                  TAG: /* Only_prefix */0,
                  _0: Dequeue_internal$ReasonDeque.snoc(triple._0, x)
                };
      case /* Only_green */1 :
          return {
                  TAG: /* Only_green */1,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      case /* Only_yellow */2 :
          return {
                  TAG: /* Only_yellow */2,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      case /* Only_orange */3 :
          return {
                  TAG: /* Only_orange */3,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      case /* Only_red */4 :
          return {
                  TAG: /* Only_red */4,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      
    }
  }
  
}

function is_hole(param) {
  if (typeof param === "number") {
    return /* Is_hole */0;
  } else {
    return /* Not_hole */1;
  }
}

function cons_only_path(x, param) {
  var kont = param._1;
  var only = param._0;
  var match = is_hole(only);
  if (match) {
    return /* Path */{
            _0: cons_only_triple(x, only),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: only,
            _1: cons_only_triple(x, kont)
          };
  }
}

function snoc_only_path(param, x) {
  var kont = param._1;
  var only = param._0;
  var match = is_hole(only);
  if (match) {
    return /* Path */{
            _0: snoc_only_triple(only, x),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: /* HOLE */0,
            _1: snoc_only_triple(kont, x)
          };
  }
}

function cons_left_triple(x, triple) {
  if (typeof triple !== "number") {
    switch (triple.TAG | 0) {
      case /* Left_small */5 :
          return {
                  TAG: /* Left_small */5,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1
                };
      case /* Left_green */6 :
          return {
                  TAG: /* Left_green */6,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      case /* Left_yellow */7 :
          return {
                  TAG: /* Left_yellow */7,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      case /* Left_orange */8 :
          return {
                  TAG: /* Left_orange */8,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      case /* Left_red */9 :
          return {
                  TAG: /* Left_red */9,
                  _0: Dequeue_internal$ReasonDeque.cons(x, triple._0),
                  _1: triple._1,
                  _2: triple._2
                };
      
    }
  }
  
}

function snoc_right_triple(triple, x) {
  if (typeof triple !== "number") {
    switch (triple.TAG | 0) {
      case /* Right_small */10 :
          return {
                  TAG: /* Right_small */10,
                  _0: triple._0,
                  _1: Dequeue_internal$ReasonDeque.snoc(triple._1, x)
                };
      case /* Right_green */11 :
          return {
                  TAG: /* Right_green */11,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      case /* Right_yellow */12 :
          return {
                  TAG: /* Right_yellow */12,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      case /* Right_orange */13 :
          return {
                  TAG: /* Right_orange */13,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      case /* Right_red */14 :
          return {
                  TAG: /* Right_red */14,
                  _0: triple._0,
                  _1: triple._1,
                  _2: Dequeue_internal$ReasonDeque.snoc(triple._2, x)
                };
      
    }
  }
  
}

function cons_left_path(x, param) {
  var kont = param._1;
  var left = param._0;
  var match = is_hole(left);
  if (match) {
    return /* Path */{
            _0: cons_left_triple(x, left),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: left,
            _1: cons_left_triple(x, kont)
          };
  }
}

function snoc_right_path(param, x) {
  var kont = param._1;
  var right = param._0;
  var match = is_hole(right);
  if (match) {
    return /* Path */{
            _0: snoc_right_triple(right, x),
            _1: kont
          };
  } else {
    return /* Path */{
            _0: right,
            _1: snoc_right_triple(kont, x)
          };
  }
}

function cons_deque(x, deq) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return {
                TAG: /* Only_path */0,
                _0: cons_only_path(x, deq._0)
              };
    case /* Pair_green */1 :
        return {
                TAG: /* Pair_green */1,
                _0: cons_left_path(x, deq._0),
                _1: deq._1
              };
    case /* Pair_red */2 :
        return {
                TAG: /* Pair_red */2,
                _0: cons_left_path(x, deq._0),
                _1: deq._1
              };
    
  }
}

function snoc_deque(deq, x) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return {
                TAG: /* Only_path */0,
                _0: snoc_only_path(deq._0, x)
              };
    case /* Pair_green */1 :
        return {
                TAG: /* Pair_green */1,
                _0: deq._0,
                _1: snoc_right_path(deq._1, x)
              };
    case /* Pair_red */2 :
        return {
                TAG: /* Pair_red */2,
                _0: deq._0,
                _1: snoc_right_path(deq._1, x)
              };
    
  }
}

function single_triple(x) {
  return {
          TAG: /* Only_prefix */0,
          _0: Dequeue_internal$ReasonDeque.cons(x, Dequeue_internal$ReasonDeque.empty)
        };
}

function only_single(x) {
  return {
          TAG: /* Only_path */0,
          _0: /* Path */{
            _0: /* HOLE */0,
            _1: {
              TAG: /* Only_prefix */0,
              _0: Dequeue_internal$ReasonDeque.cons(x, Dequeue_internal$ReasonDeque.empty)
            }
          }
        };
}

function single$1(x) {
  return /* T */{
          _0: only_single(x)
        };
}

function cons_t(x, t) {
  if (t) {
    return /* T */{
            _0: cons_deque(x, t._0)
          };
  } else {
    return /* T */{
            _0: only_single(x)
          };
  }
}

function snoc_t(t, x) {
  if (t) {
    return /* T */{
            _0: snoc_deque(t._0, x)
          };
  } else {
    return /* T */{
            _0: only_single(x)
          };
  }
}

function cons$1(x, t) {
  return /* Regular */{
          _0: cons_t(x, t._0)
        };
}

function snoc$1(t, x) {
  return /* Regular */{
          _0: snoc_t(t._0, x)
        };
}

function cons_semi(x, t) {
  return /* S */{
          _0: cons_t(x, t._0)
        };
}

function snoc_semi(t, x) {
  return /* S */{
          _0: snoc_t(t._0, x)
        };
}

function cons_vector$1(v, t) {
  return vector_fold_right(cons$1, v, t);
}

function snoc_vector$1(t, v) {
  return vector_fold_left(snoc$1, t, v);
}

function cons_semi_vector(v, t) {
  return vector_fold_right(cons_semi, v, t);
}

function snoc_semi_vector(t, v) {
  return vector_fold_left(snoc_semi, t, v);
}

function color(param) {
  if (typeof param === "number") {
    return /* Is_green */0;
  }
  switch (param.TAG | 0) {
    case /* Only_red */4 :
    case /* Left_red */9 :
    case /* Right_red */14 :
        return /* Is_red */1;
    default:
      return /* Is_green */0;
  }
}

function color_path(param) {
  return color(param._1);
}

function color_deque(t) {
  switch (t.TAG | 0) {
    case /* Only_path */0 :
        return color_path(t._0);
    case /* Pair_green */1 :
        return /* Is_red */1;
    case /* Pair_red */2 :
        return /* Is_green */0;
    
  }
}

function color_st(t) {
  if (t) {
    return color_deque(t._0);
  } else {
    return /* Is_green */0;
  }
}

function pref_left(param) {
  switch (param.TAG | 0) {
    case /* Only_path */0 :
        var match = param._0;
        return /* Pref_left */{
                _0: {
                  TAG: /* Only_of */0,
                  _0: match._0
                },
                _1: match._1
              };
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  var match$1 = param._0;
  return /* Pref_left */{
          _0: {
            TAG: /* Pair_left */1,
            _0: match$1._0,
            _1: param._1
          },
          _1: match$1._1
        };
}

function pref_right(deq, ft) {
  if (deq.TAG === /* Only_of */0) {
    return /* Pref_right */{
            _0: {
              TAG: /* Only_of */0,
              _0: deq._0
            },
            _1: ft
          };
  }
  var match = deq._1;
  return /* Pref_right */{
          _0: {
            TAG: /* Pair_right */2,
            _0: /* Path */{
              _0: deq._0,
              _1: ft
            },
            _1: match._0
          },
          _1: match._1
        };
}

function no_pref(d1, ght) {
  if (d1.TAG === /* Only_of */0) {
    return {
            TAG: /* Only_path */0,
            _0: /* Path */{
              _0: d1._0,
              _1: ght
            }
          };
  } else {
    return {
            TAG: /* Pair_red */2,
            _0: d1._0,
            _1: /* Path */{
              _0: d1._1,
              _1: ght
            }
          };
  }
}

function make_child(ne_deq, trip) {
  var match = color(trip);
  if (match) {
    switch (ne_deq.TAG | 0) {
      case /* Only_of */0 :
          return /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: /* Path */{
                        _0: ne_deq._0,
                        _1: trip
                      }
                    }
                  }
                };
      case /* Pair_left */1 :
          return /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Pair_green */1,
                      _0: /* Path */{
                        _0: ne_deq._0,
                        _1: trip
                      },
                      _1: ne_deq._1
                    }
                  }
                };
      case /* Pair_right */2 :
          return /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Pair_green */1,
                      _0: ne_deq._0,
                      _1: /* Path */{
                        _0: ne_deq._1,
                        _1: trip
                      }
                    }
                  }
                };
      
    }
  } else {
    switch (ne_deq.TAG | 0) {
      case /* Only_of */0 :
          return /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: /* Path */{
                        _0: ne_deq._0,
                        _1: trip
                      }
                    }
                  }
                };
      case /* Pair_left */1 :
          return /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Pair_green */1,
                      _0: /* Path */{
                        _0: ne_deq._0,
                        _1: trip
                      },
                      _1: ne_deq._1
                    }
                  }
                };
      case /* Pair_right */2 :
          return /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Pair_red */2,
                      _0: ne_deq._0,
                      _1: /* Path */{
                        _0: ne_deq._1,
                        _1: trip
                      }
                    }
                  }
                };
      
    }
  }
}

function cons_child(x, ne_deq, trip) {
  switch (ne_deq.TAG | 0) {
    case /* Only_of */0 :
        var only = ne_deq._0;
        var match = is_hole(only);
        if (match) {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: cons_only_triple(x, only)
                  },
                  trip
                ];
        } else {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: /* HOLE */0
                  },
                  cons_only_triple(x, trip)
                ];
        }
    case /* Pair_left */1 :
        var right = ne_deq._1;
        var left = ne_deq._0;
        var match$1 = is_hole(left);
        if (match$1) {
          return [
                  {
                    TAG: /* Pair_left */1,
                    _0: cons_left_triple(x, left),
                    _1: right
                  },
                  trip
                ];
        } else {
          return [
                  {
                    TAG: /* Pair_left */1,
                    _0: /* HOLE */0,
                    _1: right
                  },
                  cons_left_triple(x, trip)
                ];
        }
    case /* Pair_right */2 :
        return [
                {
                  TAG: /* Pair_right */2,
                  _0: cons_left_path(x, ne_deq._0),
                  _1: ne_deq._1
                },
                trip
              ];
    
  }
}

function snoc_child(ne_deq, trip, x) {
  switch (ne_deq.TAG | 0) {
    case /* Only_of */0 :
        var only = ne_deq._0;
        var match = is_hole(only);
        if (match) {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: snoc_only_triple(only, x)
                  },
                  trip
                ];
        } else {
          return [
                  {
                    TAG: /* Only_of */0,
                    _0: only
                  },
                  snoc_only_triple(trip, x)
                ];
        }
    case /* Pair_left */1 :
        return [
                {
                  TAG: /* Pair_left */1,
                  _0: ne_deq._0,
                  _1: snoc_right_path(ne_deq._1, x)
                },
                trip
              ];
    case /* Pair_right */2 :
        var right = ne_deq._1;
        var left = ne_deq._0;
        var match$1 = is_hole(right);
        if (match$1) {
          return [
                  {
                    TAG: /* Pair_right */2,
                    _0: left,
                    _1: snoc_right_triple(right, x)
                  },
                  trip
                ];
        } else {
          return [
                  {
                    TAG: /* Pair_right */2,
                    _0: left,
                    _1: right
                  },
                  snoc_right_triple(trip, x)
                ];
        }
    
  }
}

function stored_left(p2, d2, s2, s1) {
  var t = Dequeue_internal$ReasonDeque.snoc(s2, s1[0]);
  var s2$1 = vector_fold_left(Dequeue_internal$ReasonDeque.snoc, t, s1[1]);
  var match = uncons(p2);
  var match$1 = uncons(match[1]);
  var s3 = pair(match[0], match$1[0]);
  return [
          s3,
          {
            TAG: /* Stored */1,
            _0: match$1[1],
            _1: d2,
            _2: s2$1
          }
        ];
}

function stored_right(s1, p2, d2, s2) {
  var p2$1 = Dequeue_internal$ReasonDeque.cons(s1[0], vector_fold_right(Dequeue_internal$ReasonDeque.cons, s1[1], p2));
  var match = unsnoc2(s2);
  var s3 = pair(match[1], match[2]);
  return [
          {
            TAG: /* Stored */1,
            _0: p2$1,
            _1: d2,
            _2: match[0]
          },
          s3
        ];
}

function extract_stored_left(left, s1) {
  var match = left._0;
  if (typeof match === "number") {
    var match$1 = left._1;
    if (typeof match$1 !== "number") {
      switch (match$1.TAG | 0) {
        case /* Left_small */5 :
            return stored_left(match$1._0, /* Void */0, match$1._1, s1);
        case /* Left_green */6 :
        case /* Left_red */9 :
            break;
        
      }
    }
    return stored_left(match$1._0, /* T */{
                _0: match$1._1
              }, match$1._2, s1);
  }
  var d2 = make_child(match._1, left._1);
  return stored_left(match._0, d2._0, match._2, s1);
}

function extract_stored_right(s1, right) {
  var match = right._0;
  if (typeof match === "number") {
    var match$1 = right._1;
    if (typeof match$1 !== "number") {
      switch (match$1.TAG | 0) {
        case /* Right_small */10 :
            return stored_right(s1, match$1._0, /* Void */0, match$1._1);
        case /* Right_green */11 :
        case /* Right_red */14 :
            break;
        
      }
    }
    return stored_right(s1, match$1._0, /* T */{
                _0: match$1._1
              }, match$1._2);
  }
  var d2 = make_child(match._1, right._1);
  return stored_right(s1, match._0, d2._0, match._2);
}

function left_of_pair(left, right) {
  var match = color_path(left);
  var match$1 = left._0;
  if (typeof match$1 === "number") {
    if (match) {
      var match$2 = left._1;
      var match$3 = two(match$2._2);
      var s1_0 = match$3[0];
      var s1_1 = {
        TAG: /* V1 */0,
        _0: match$3[1]
      };
      var s1 = [
        s1_0,
        s1_1
      ];
      var match$4 = extract_stored_right(s1, right);
      var d1 = snoc_deque(match$2._1, match$4[0]);
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Left_red */9,
                _0: match$2._0,
                _1: d1,
                _2: match$4[1]
              }
            };
    }
    var match$5 = left._1;
    if (typeof match$5 !== "number") {
      if (match$5.TAG === /* Left_small */5) {
        var match$6 = two(match$5._1);
        var p1 = Dequeue_internal$ReasonDeque.snoc(match$5._0, match$6[0]);
        var s1_0$1 = match$6[1];
        var s1$1 = [
          s1_0$1,
          /* V0 */0
        ];
        var match$7 = extract_stored_right(s1$1, right);
        return /* Path */{
                _0: {
                  TAG: /* Left_orange */8,
                  _0: p1,
                  _1: {
                    TAG: /* Only_of */0,
                    _0: /* HOLE */0
                  },
                  _2: match$7[1]
                },
                _1: {
                  TAG: /* Only_prefix */0,
                  _0: Dequeue_internal$ReasonDeque.cons(match$7[0], Dequeue_internal$ReasonDeque.empty)
                }
              };
      }
      var match$8 = two(match$5._2);
      var s1_0$2 = match$8[0];
      var s1_1$1 = {
        TAG: /* V1 */0,
        _0: match$8[1]
      };
      var s1$2 = [
        s1_0$2,
        s1_1$1
      ];
      var match$9 = extract_stored_right(s1$2, right);
      var d1$1 = snoc_deque(match$5._1, match$9[0]);
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Left_green */6,
                _0: match$5._0,
                _1: d1$1,
                _2: match$9[1]
              }
            };
    }
    
  } else {
    if (match$1.TAG === /* Left_yellow */7) {
      var match$10 = two(match$1._2);
      var s1_0$3 = match$10[0];
      var s1_1$2 = {
        TAG: /* V1 */0,
        _0: match$10[1]
      };
      var s1$3 = [
        s1_0$3,
        s1_1$2
      ];
      var match$11 = extract_stored_right(s1$3, right);
      var match$12 = snoc_child(match$1._1, left._1, match$11[0]);
      return /* Path */{
              _0: {
                TAG: /* Left_yellow */7,
                _0: match$1._0,
                _1: match$12[0],
                _2: match$11[1]
              },
              _1: match$12[1]
            };
    }
    var match$13 = two(match$1._2);
    var s1_0$4 = match$13[0];
    var s1_1$3 = {
      TAG: /* V1 */0,
      _0: match$13[1]
    };
    var s1$4 = [
      s1_0$4,
      s1_1$3
    ];
    var match$14 = extract_stored_right(s1$4, right);
    var match$15 = snoc_child(match$1._1, left._1, match$14[0]);
    return /* Path */{
            _0: {
              TAG: /* Left_orange */8,
              _0: match$1._0,
              _1: match$15[0],
              _2: match$14[1]
            },
            _1: match$15[1]
          };
  }
}

function right_of_pair(left, right) {
  var match = color_path(right);
  var match$1 = right._0;
  if (typeof match$1 === "number") {
    if (match) {
      var match$2 = right._1;
      var match$3 = two(match$2._0);
      var p1_0 = match$3[0];
      var p1_1 = {
        TAG: /* V1 */0,
        _0: match$3[1]
      };
      var p1 = [
        p1_0,
        p1_1
      ];
      var match$4 = extract_stored_left(left, p1);
      var d1 = cons_deque(match$4[1], match$2._1);
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Right_red */14,
                _0: match$4[0],
                _1: d1,
                _2: match$2._2
              }
            };
    }
    var match$5 = right._1;
    if (typeof match$5 !== "number") {
      if (match$5.TAG === /* Right_small */10) {
        var match$6 = two(match$5._0);
        var p1_0$1 = match$6[0];
        var p1$1 = [
          p1_0$1,
          /* V0 */0
        ];
        var s1 = Dequeue_internal$ReasonDeque.cons(match$6[1], match$5._1);
        var match$7 = extract_stored_left(left, p1$1);
        return /* Path */{
                _0: {
                  TAG: /* Right_orange */13,
                  _0: match$7[0],
                  _1: {
                    TAG: /* Only_of */0,
                    _0: /* HOLE */0
                  },
                  _2: s1
                },
                _1: {
                  TAG: /* Only_prefix */0,
                  _0: Dequeue_internal$ReasonDeque.cons(match$7[1], Dequeue_internal$ReasonDeque.empty)
                }
              };
      }
      var match$8 = two(match$5._0);
      var p1_0$2 = match$8[0];
      var p1_1$1 = {
        TAG: /* V1 */0,
        _0: match$8[1]
      };
      var p1$2 = [
        p1_0$2,
        p1_1$1
      ];
      var match$9 = extract_stored_left(left, p1$2);
      var d1$1 = cons_deque(match$9[1], match$5._1);
      return /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Right_green */11,
                _0: match$9[0],
                _1: d1$1,
                _2: match$5._2
              }
            };
    }
    
  } else {
    if (match$1.TAG === /* Right_yellow */12) {
      var match$10 = two(match$1._0);
      var p1_0$3 = match$10[0];
      var p1_1$2 = {
        TAG: /* V1 */0,
        _0: match$10[1]
      };
      var p1$3 = [
        p1_0$3,
        p1_1$2
      ];
      var match$11 = extract_stored_left(left, p1$3);
      var match$12 = cons_child(match$11[1], match$1._1, right._1);
      return /* Path */{
              _0: {
                TAG: /* Right_yellow */12,
                _0: match$11[0],
                _1: match$12[0],
                _2: match$1._2
              },
              _1: match$12[1]
            };
    }
    var match$13 = two(match$1._0);
    var p1_0$4 = match$13[0];
    var p1_1$3 = {
      TAG: /* V1 */0,
      _0: match$13[1]
    };
    var p1$4 = [
      p1_0$4,
      p1_1$3
    ];
    var match$14 = extract_stored_left(left, p1$4);
    var match$15 = cons_child(match$14[1], match$1._1, right._1);
    return /* Path */{
            _0: {
              TAG: /* Right_orange */13,
              _0: match$14[0],
              _1: match$15[0],
              _2: match$1._2
            },
            _1: match$15[1]
          };
  }
}

function left_of_only(path) {
  var match = color_path(path);
  var match$1 = path._0;
  if (typeof match$1 === "number") {
    if (match) {
      var match$2 = path._1;
      var match$3 = unsnoc2(match$2._2);
      var s1$prime = pair(match$3[1], match$3[2]);
      var d1 = snoc_deque(match$2._1, {
            TAG: /* Stored_prefix */0,
            _0: match$3[0]
          });
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Left_red */9,
                  _0: match$2._0,
                  _1: d1,
                  _2: s1$prime
                }
              }
            };
    }
    var p1 = path._1;
    if (typeof p1 !== "number") {
      if (p1.TAG === /* Only_prefix */0) {
        var vec = has5p2(p1._0);
        if (vec.TAG === /* Less_than_5p2 */0) {
          return {
                  TAG: /* Small */0,
                  _0: vec._0
                };
        }
        var s1 = pair(vec._1, vec._2);
        return {
                TAG: /* Ok */1,
                _0: /* Path */{
                  _0: /* HOLE */0,
                  _1: {
                    TAG: /* Left_small */5,
                    _0: vec._0,
                    _1: s1
                  }
                }
              };
      }
      var match$4 = unsnoc2(p1._2);
      var s1$prime$1 = pair(match$4[1], match$4[2]);
      var d1$1 = snoc_deque(p1._1, {
            TAG: /* Stored_prefix */0,
            _0: match$4[0]
          });
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Left_green */6,
                  _0: p1._0,
                  _1: d1$1,
                  _2: s1$prime$1
                }
              }
            };
    }
    
  } else {
    if (match$1.TAG === /* Only_yellow */2) {
      var match$5 = unsnoc2(match$1._2);
      var s1$prime$2 = pair(match$5[1], match$5[2]);
      var match$6 = snoc_child(match$1._1, path._1, {
            TAG: /* Stored_prefix */0,
            _0: match$5[0]
          });
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: {
                  TAG: /* Left_yellow */7,
                  _0: match$1._0,
                  _1: match$6[0],
                  _2: s1$prime$2
                },
                _1: match$6[1]
              }
            };
    }
    var match$7 = unsnoc2(match$1._2);
    var s1$prime$3 = pair(match$7[1], match$7[2]);
    var match$8 = snoc_child(match$1._1, path._1, {
          TAG: /* Stored_prefix */0,
          _0: match$7[0]
        });
    return {
            TAG: /* Ok */1,
            _0: /* Path */{
              _0: {
                TAG: /* Left_orange */8,
                _0: match$1._0,
                _1: match$8[0],
                _2: s1$prime$3
              },
              _1: match$8[1]
            }
          };
  }
}

function right_of_only(path) {
  var match = color_path(path);
  var match$1 = path._0;
  if (typeof match$1 === "number") {
    if (match) {
      var match$2 = path._1;
      var match$3 = uncons2(match$2._0);
      var d1 = cons_deque({
            TAG: /* Stored_prefix */0,
            _0: match$3[2]
          }, match$2._1);
      var p1$prime = pair(match$3[0], match$3[1]);
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Right_red */14,
                  _0: p1$prime,
                  _1: d1,
                  _2: match$2._2
                }
              }
            };
    }
    var p1 = path._1;
    if (typeof p1 !== "number") {
      if (p1.TAG === /* Only_prefix */0) {
        var vec = has2p5(p1._0);
        if (vec.TAG === /* Less_than_2p5 */0) {
          return {
                  TAG: /* Small */0,
                  _0: vec._0
                };
        }
        var p1$1 = pair(vec._0, vec._1);
        return {
                TAG: /* Ok */1,
                _0: /* Path */{
                  _0: /* HOLE */0,
                  _1: {
                    TAG: /* Right_small */10,
                    _0: p1$1,
                    _1: vec._2
                  }
                }
              };
      }
      var match$4 = uncons2(p1._0);
      var d1$1 = cons_deque({
            TAG: /* Stored_prefix */0,
            _0: match$4[2]
          }, p1._1);
      var p1$prime$1 = pair(match$4[0], match$4[1]);
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Right_green */11,
                  _0: p1$prime$1,
                  _1: d1$1,
                  _2: p1._2
                }
              }
            };
    }
    
  } else {
    if (match$1.TAG === /* Only_yellow */2) {
      var match$5 = uncons2(match$1._0);
      var match$6 = cons_child({
            TAG: /* Stored_prefix */0,
            _0: match$5[2]
          }, match$1._1, path._1);
      var p1$prime$2 = pair(match$5[0], match$5[1]);
      return {
              TAG: /* Ok */1,
              _0: /* Path */{
                _0: {
                  TAG: /* Right_yellow */12,
                  _0: p1$prime$2,
                  _1: match$6[0],
                  _2: match$1._2
                },
                _1: match$6[1]
              }
            };
    }
    var match$7 = uncons2(match$1._0);
    var match$8 = cons_child({
          TAG: /* Stored_prefix */0,
          _0: match$7[2]
        }, match$1._1, path._1);
    var p1$prime$3 = pair(match$7[0], match$7[1]);
    return {
            TAG: /* Ok */1,
            _0: /* Path */{
              _0: {
                TAG: /* Right_orange */13,
                _0: p1$prime$3,
                _1: match$8[0],
                _2: match$1._2
              },
              _1: match$8[1]
            }
          };
  }
}

function make_left(st) {
  var match = color_st(st);
  if (!st) {
    return {
            TAG: /* Small */0,
            _0: /* V0 */0
          };
  }
  var only = st._0;
  switch (only.TAG | 0) {
    case /* Only_path */0 :
        return left_of_only(only._0);
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  if (match) {
    var match$1 = st._0;
    return {
            TAG: /* Any */2,
            _0: left_of_pair(match$1._0, match$1._1)
          };
  }
  var match$2 = st._0;
  return {
          TAG: /* Ok */1,
          _0: left_of_pair(match$2._0, match$2._1)
        };
}

function make_right(st) {
  var match = color_st(st);
  if (!st) {
    return {
            TAG: /* Small */0,
            _0: /* V0 */0
          };
  }
  var only = st._0;
  switch (only.TAG | 0) {
    case /* Only_path */0 :
        return right_of_only(only._0);
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  if (match) {
    var match$1 = st._0;
    return {
            TAG: /* Any */2,
            _0: right_of_pair(match$1._0, match$1._1)
          };
  }
  var match$2 = st._0;
  return {
          TAG: /* Ok */1,
          _0: right_of_pair(match$2._0, match$2._1)
        };
}

function concat_semi(deq_left, deq_right) {
  var dr = deq_right._0;
  var vec = make_left(deq_left._0);
  switch (vec.TAG | 0) {
    case /* Small */0 :
        return cons_semi_vector(vec._0, deq_right);
    case /* Ok */1 :
        var vec$1 = make_right(dr);
        switch (vec$1.TAG | 0) {
          case /* Small */0 :
              return snoc_semi_vector(deq_left, vec$1._0);
          case /* Ok */1 :
          case /* Any */2 :
              break;
          
        }
        return /* S */{
                _0: /* T */{
                  _0: {
                    TAG: /* Pair_green */1,
                    _0: vec._0,
                    _1: vec$1._0
                  }
                }
              };
    case /* Any */2 :
        var vec$2 = make_right(dr);
        switch (vec$2.TAG | 0) {
          case /* Small */0 :
              return snoc_semi_vector(deq_left, vec$2._0);
          case /* Ok */1 :
          case /* Any */2 :
              break;
          
        }
        return /* S */{
                _0: /* T */{
                  _0: {
                    TAG: /* Pair_green */1,
                    _0: vec._0,
                    _1: vec$2._0
                  }
                }
              };
    
  }
}

function concat(deq_left, deq_right) {
  var vec = make_left(deq_left._0);
  if (vec.TAG === /* Small */0) {
    return cons_vector$1(vec._0, deq_right);
  }
  var vec$1 = make_right(deq_right._0);
  if (vec$1.TAG === /* Small */0) {
    return snoc_vector$1(deq_left, vec$1._0);
  } else {
    return /* Regular */{
            _0: /* T */{
              _0: {
                TAG: /* Pair_red */2,
                _0: vec._0,
                _1: vec$1._0
              }
            }
          };
  }
}

function semi_of_left(left, six) {
  var match = color_path(left);
  if (match) {
    if (typeof left._0 === "number") {
      var match$1 = left._1;
      var s2 = snoc6(match$1._2, six);
      return /* S */{
              _0: /* T */{
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_red */4,
                      _0: match$1._0,
                      _1: match$1._1,
                      _2: s2
                    }
                  }
                }
              }
            };
    }
    
  } else if (typeof left._0 === "number") {
    var match$2 = left._1;
    if (typeof match$2 !== "number") {
      if (match$2.TAG === /* Left_small */5) {
        var match$3 = two(match$2._1);
        var p2 = snoc2(match$2._0, [
              match$3[0],
              match$3[1]
            ]);
        var p2$1 = snoc6(p2, six);
        return /* S */{
                _0: /* T */{
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */0,
                        _0: p2$1
                      }
                    }
                  }
                }
              };
      }
      var s2$1 = snoc6(match$2._2, six);
      return /* S */{
              _0: /* T */{
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_green */1,
                      _0: match$2._0,
                      _1: match$2._1,
                      _2: s2$1
                    }
                  }
                }
              }
            };
    }
    
  }
  var match$4 = left._0;
  if (typeof match$4 !== "number") {
    if (match$4.TAG === /* Left_yellow */7) {
      var s2$2 = snoc6(match$4._2, six);
      return /* S */{
              _0: /* T */{
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: {
                      TAG: /* Only_yellow */2,
                      _0: match$4._0,
                      _1: match$4._1,
                      _2: s2$2
                    },
                    _1: left._1
                  }
                }
              }
            };
    }
    var s2$3 = snoc6(match$4._2, six);
    return /* S */{
            _0: /* T */{
              _0: {
                TAG: /* Only_path */0,
                _0: /* Path */{
                  _0: {
                    TAG: /* Only_orange */3,
                    _0: match$4._0,
                    _1: match$4._1,
                    _2: s2$3
                  },
                  _1: left._1
                }
              }
            }
          };
  }
  
}

function semi_of_right(six, right) {
  var match = color_path(right);
  if (match) {
    if (typeof right._0 === "number") {
      var match$1 = right._1;
      var p2 = cons6(six, match$1._0);
      return /* S */{
              _0: /* T */{
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_red */4,
                      _0: p2,
                      _1: match$1._1,
                      _2: match$1._2
                    }
                  }
                }
              }
            };
    }
    
  } else if (typeof right._0 === "number") {
    var match$2 = right._1;
    if (typeof match$2 !== "number") {
      if (match$2.TAG === /* Right_small */10) {
        var match$3 = two(match$2._0);
        var s2 = cons2([
              match$3[0],
              match$3[1]
            ], match$2._1);
        var s2$1 = cons6(six, s2);
        return /* S */{
                _0: /* T */{
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */0,
                        _0: s2$1
                      }
                    }
                  }
                }
              };
      }
      var p2$1 = cons6(six, match$2._0);
      return /* S */{
              _0: /* T */{
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: /* HOLE */0,
                    _1: {
                      TAG: /* Only_green */1,
                      _0: p2$1,
                      _1: match$2._1,
                      _2: match$2._2
                    }
                  }
                }
              }
            };
    }
    
  }
  var match$4 = right._0;
  if (typeof match$4 !== "number") {
    if (match$4.TAG === /* Right_yellow */12) {
      var p2$2 = cons6(six, match$4._0);
      return /* S */{
              _0: /* T */{
                _0: {
                  TAG: /* Only_path */0,
                  _0: /* Path */{
                    _0: {
                      TAG: /* Only_yellow */2,
                      _0: p2$2,
                      _1: match$4._1,
                      _2: match$4._2
                    },
                    _1: right._1
                  }
                }
              }
            };
    }
    var p2$3 = cons6(six, match$4._0);
    return /* S */{
            _0: /* T */{
              _0: {
                TAG: /* Only_path */0,
                _0: /* Path */{
                  _0: {
                    TAG: /* Only_orange */3,
                    _0: p2$3,
                    _1: match$4._1,
                    _2: match$4._2
                  },
                  _1: right._1
                }
              }
            }
          };
  }
  
}

function uncons_green_left(param) {
  var match = param._0;
  if (typeof match === "number") {
    var match$1 = param._1;
    if (typeof match$1 !== "number") {
      if (match$1.TAG === /* Left_small */5) {
        var s1 = match$1._1;
        var match$2 = uncons(match$1._0);
        var p1 = has5(match$2[1]);
        var result;
        if (p1.TAG === /* Exact_4 */0) {
          var match$3 = p1._0;
          var match$4 = two(s1);
          result = {
            TAG: /* Exact_6 */0,
            _0: [
              match$3[0],
              match$3[1],
              match$3[2],
              match$3[3],
              match$4[0],
              match$4[1]
            ]
          };
        } else {
          result = {
            TAG: /* Any */1,
            _0: /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Left_small */5,
                _0: p1._0,
                _1: s1
              }
            }
          };
        }
        return [
                match$2[0],
                result
              ];
      }
      var match$5 = uncons(match$1._0);
      var match$6 = pref_left(match$1._1);
      var path_0 = {
        TAG: /* Left_yellow */7,
        _0: match$5[1],
        _1: match$6._0,
        _2: match$1._2
      };
      var path_1 = match$6._1;
      var path = /* Path */{
        _0: path_0,
        _1: path_1
      };
      return [
              match$5[0],
              {
                TAG: /* Any */1,
                _0: path
              }
            ];
    }
    
  } else {
    if (match.TAG === /* Left_yellow */7) {
      var match$7 = uncons(match._0);
      var match$8 = pref_right(match._1, param._1);
      var path_0$1 = {
        TAG: /* Left_orange */8,
        _0: match$7[1],
        _1: match$8._0,
        _2: match._2
      };
      var path_1$1 = match$8._1;
      var path$1 = /* Path */{
        _0: path_0$1,
        _1: path_1$1
      };
      return [
              match$7[0],
              {
                TAG: /* Any */1,
                _0: path$1
              }
            ];
    }
    var match$9 = uncons(match._0);
    var d1 = no_pref(match._1, param._1);
    var path_1$2 = {
      TAG: /* Left_red */9,
      _0: match$9[1],
      _1: d1,
      _2: match._2
    };
    var path$2 = /* Path */{
      _0: /* HOLE */0,
      _1: path_1$2
    };
    return [
            match$9[0],
            {
              TAG: /* Any */1,
              _0: path$2
            }
          ];
  }
}

function unsnoc_green_right(param) {
  var match = param._0;
  if (typeof match === "number") {
    var match$1 = param._1;
    if (typeof match$1 !== "number") {
      if (match$1.TAG === /* Right_small */10) {
        var p1 = match$1._0;
        var match$2 = unsnoc(match$1._1);
        var s1 = has5(match$2[0]);
        var result;
        if (s1.TAG === /* Exact_4 */0) {
          var match$3 = s1._0;
          var match$4 = two(p1);
          result = {
            TAG: /* Exact_6 */0,
            _0: [
              match$4[0],
              match$4[1],
              match$3[0],
              match$3[1],
              match$3[2],
              match$3[3]
            ]
          };
        } else {
          result = {
            TAG: /* Any */1,
            _0: /* Path */{
              _0: /* HOLE */0,
              _1: {
                TAG: /* Right_small */10,
                _0: p1,
                _1: s1._0
              }
            }
          };
        }
        return [
                result,
                match$2[1]
              ];
      }
      var match$5 = unsnoc(match$1._2);
      var match$6 = pref_left(match$1._1);
      var path_0 = {
        TAG: /* Right_yellow */12,
        _0: match$1._0,
        _1: match$6._0,
        _2: match$5[0]
      };
      var path_1 = match$6._1;
      var path = /* Path */{
        _0: path_0,
        _1: path_1
      };
      return [
              {
                TAG: /* Any */1,
                _0: path
              },
              match$5[1]
            ];
    }
    
  } else {
    if (match.TAG === /* Right_yellow */12) {
      var match$7 = unsnoc(match._2);
      var match$8 = pref_right(match._1, param._1);
      var path_0$1 = {
        TAG: /* Right_orange */13,
        _0: match._0,
        _1: match$8._0,
        _2: match$7[0]
      };
      var path_1$1 = match$8._1;
      var path$1 = /* Path */{
        _0: path_0$1,
        _1: path_1$1
      };
      return [
              {
                TAG: /* Any */1,
                _0: path$1
              },
              match$7[1]
            ];
    }
    var match$9 = unsnoc(match._2);
    var d1 = no_pref(match._1, param._1);
    var path_1$2 = {
      TAG: /* Right_red */14,
      _0: match._0,
      _1: d1,
      _2: match$9[0]
    };
    var path$2 = /* Path */{
      _0: /* HOLE */0,
      _1: path_1$2
    };
    return [
            {
              TAG: /* Any */1,
              _0: path$2
            },
            match$9[1]
          ];
  }
}

function uncons_green(param) {
  if (param.TAG === /* Only_path */0) {
    var match = param._0;
    var match$1 = match._0;
    if (typeof match$1 === "number") {
      var p1 = match._1;
      if (typeof p1 !== "number") {
        if (p1.TAG === /* Only_prefix */0) {
          var match$2 = uncons(p1._0);
          var p1$1 = has1(match$2[1]);
          return [
                  match$2[0],
                  p1$1 ? /* S */({
                        _0: /* T */{
                          _0: {
                            TAG: /* Only_path */0,
                            _0: /* Path */{
                              _0: /* HOLE */0,
                              _1: {
                                TAG: /* Only_prefix */0,
                                _0: p1$1._0
                              }
                            }
                          }
                        }
                      }) : /* S */({
                        _0: /* Void */0
                      })
                ];
        }
        var match$3 = uncons(p1._0);
        var match$4 = pref_left(p1._1);
        var only_0 = {
          TAG: /* Only_yellow */2,
          _0: match$3[1],
          _1: match$4._0,
          _2: p1._2
        };
        var only_1 = match$4._1;
        var only = /* Path */{
          _0: only_0,
          _1: only_1
        };
        return [
                match$3[0],
                /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only
                    }
                  }
                }
              ];
      }
      
    } else {
      if (match$1.TAG === /* Only_yellow */2) {
        var match$5 = uncons(match$1._0);
        var match$6 = pref_right(match$1._1, match._1);
        var only_0$1 = {
          TAG: /* Only_orange */3,
          _0: match$5[1],
          _1: match$6._0,
          _2: match$1._2
        };
        var only_1$1 = match$6._1;
        var only$1 = /* Path */{
          _0: only_0$1,
          _1: only_1$1
        };
        return [
                match$5[0],
                /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only$1
                    }
                  }
                }
              ];
      }
      var match$7 = uncons(match$1._0);
      var d1 = no_pref(match$1._1, match._1);
      var only_1$2 = {
        TAG: /* Only_red */4,
        _0: match$7[1],
        _1: d1,
        _2: match$1._2
      };
      var only$2 = /* Path */{
        _0: /* HOLE */0,
        _1: only_1$2
      };
      return [
              match$7[0],
              /* S */{
                _0: /* T */{
                  _0: {
                    TAG: /* Only_path */0,
                    _0: only$2
                  }
                }
              }
            ];
    }
  } else {
    var right = param._1;
    var match$8 = uncons_green_left(param._0);
    var result = match$8[1];
    var tmp;
    tmp = result.TAG === /* Exact_6 */0 ? semi_of_right(result._0, right) : /* S */({
          _0: /* T */{
            _0: {
              TAG: /* Pair_green */1,
              _0: result._0,
              _1: right
            }
          }
        });
    return [
            match$8[0],
            tmp
          ];
  }
}

function unsnoc_green(param) {
  if (param.TAG === /* Only_path */0) {
    var match = param._0;
    var match$1 = match._0;
    if (typeof match$1 === "number") {
      var p1 = match._1;
      if (typeof p1 !== "number") {
        if (p1.TAG === /* Only_prefix */0) {
          var match$2 = unsnoc(p1._0);
          var p1$1 = has1(match$2[0]);
          var result = p1$1 ? /* S */({
                _0: /* T */{
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */0,
                        _0: p1$1._0
                      }
                    }
                  }
                }
              }) : /* S */({
                _0: /* Void */0
              });
          return [
                  result,
                  match$2[1]
                ];
        }
        var match$3 = unsnoc(p1._2);
        var match$4 = pref_left(p1._1);
        var only_0 = {
          TAG: /* Only_yellow */2,
          _0: p1._0,
          _1: match$4._0,
          _2: match$3[0]
        };
        var only_1 = match$4._1;
        var only = /* Path */{
          _0: only_0,
          _1: only_1
        };
        return [
                /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only
                    }
                  }
                },
                match$3[1]
              ];
      }
      
    } else {
      if (match$1.TAG === /* Only_yellow */2) {
        var match$5 = unsnoc(match$1._2);
        var match$6 = pref_right(match$1._1, match._1);
        var only_0$1 = {
          TAG: /* Only_orange */3,
          _0: match$1._0,
          _1: match$6._0,
          _2: match$5[0]
        };
        var only_1$1 = match$6._1;
        var only$1 = /* Path */{
          _0: only_0$1,
          _1: only_1$1
        };
        return [
                /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only$1
                    }
                  }
                },
                match$5[1]
              ];
      }
      var match$7 = unsnoc(match$1._2);
      var d1 = no_pref(match$1._1, match._1);
      var only_1$2 = {
        TAG: /* Only_red */4,
        _0: match$1._0,
        _1: d1,
        _2: match$7[0]
      };
      var only$2 = /* Path */{
        _0: /* HOLE */0,
        _1: only_1$2
      };
      return [
              /* S */{
                _0: /* T */{
                  _0: {
                    TAG: /* Only_path */0,
                    _0: only$2
                  }
                }
              },
              match$7[1]
            ];
    }
  } else {
    var left = param._0;
    var match$8 = unsnoc_green_right(param._1);
    var result$1 = match$8[0];
    var result$2;
    result$2 = result$1.TAG === /* Exact_6 */0 ? semi_of_left(left, result$1._0) : /* S */({
          _0: /* T */{
            _0: {
              TAG: /* Pair_green */1,
              _0: left,
              _1: result$1._0
            }
          }
        });
    return [
            result$2,
            match$8[1]
          ];
  }
}

function uncons_stored(d1) {
  var match = uncons_green(d1);
  var d1$1 = match[1];
  var stored = match[0];
  if (stored.TAG === /* Stored_prefix */0) {
    return /* Unstored */{
            _0: stored._0,
            _1: d1$1
          };
  }
  var s2 = {
    TAG: /* Stored_prefix */0,
    _0: stored._2
  };
  var d1$2 = cons_semi(s2, d1$1);
  var d1$3 = concat_semi(/* S */{
        _0: stored._1
      }, d1$2);
  return /* Unstored */{
          _0: stored._0,
          _1: d1$3
        };
}

function unsnoc_stored(d1) {
  var match = unsnoc_green(d1);
  var stored = match[1];
  var d1$1 = match[0];
  if (stored.TAG === /* Stored_prefix */0) {
    return /* Unstored */{
            _0: stored._0,
            _1: d1$1
          };
  }
  var p2 = {
    TAG: /* Stored_prefix */0,
    _0: stored._0
  };
  var d1$2 = snoc_semi(d1$1, p2);
  var d1$3 = concat_semi(d1$2, /* S */{
        _0: stored._1
      });
  return /* Unstored */{
          _0: stored._2,
          _1: d1$3
        };
}

function unsandwich_green(param) {
  if (param.TAG === /* Only_path */0) {
    var match = param._0;
    var match$1 = match._0;
    if (typeof match$1 === "number") {
      var p1 = match._1;
      if (typeof p1 !== "number") {
        if (p1.TAG === /* Only_prefix */0) {
          var match$2 = uncons(p1._0);
          var x = match$2[0];
          var p1$1 = has1(match$2[1]);
          if (!p1$1) {
            return {
                    TAG: /* Alone */0,
                    _0: x
                  };
          }
          var match$3 = unsnoc(p1$1._0);
          var p1$2 = has1(match$3[0]);
          var d1 = p1$2 ? /* S */({
                _0: /* T */{
                  _0: {
                    TAG: /* Only_path */0,
                    _0: /* Path */{
                      _0: /* HOLE */0,
                      _1: {
                        TAG: /* Only_prefix */0,
                        _0: p1$2._0
                      }
                    }
                  }
                }
              }) : /* S */({
                _0: /* Void */0
              });
          return {
                  TAG: /* Sandwich */1,
                  _0: x,
                  _1: d1,
                  _2: match$3[1]
                };
        }
        var match$4 = uncons(p1._0);
        var match$5 = unsnoc(p1._2);
        var match$6 = pref_left(p1._1);
        var only_0 = {
          TAG: /* Only_yellow */2,
          _0: match$4[1],
          _1: match$6._0,
          _2: match$5[0]
        };
        var only_1 = match$6._1;
        var only = /* Path */{
          _0: only_0,
          _1: only_1
        };
        return {
                TAG: /* Sandwich */1,
                _0: match$4[0],
                _1: /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only
                    }
                  }
                },
                _2: match$5[1]
              };
      }
      
    } else {
      if (match$1.TAG === /* Only_yellow */2) {
        var match$7 = uncons(match$1._0);
        var match$8 = unsnoc(match$1._2);
        var match$9 = pref_right(match$1._1, match._1);
        var only_0$1 = {
          TAG: /* Only_orange */3,
          _0: match$7[1],
          _1: match$9._0,
          _2: match$8[0]
        };
        var only_1$1 = match$9._1;
        var only$1 = /* Path */{
          _0: only_0$1,
          _1: only_1$1
        };
        return {
                TAG: /* Sandwich */1,
                _0: match$7[0],
                _1: /* S */{
                  _0: /* T */{
                    _0: {
                      TAG: /* Only_path */0,
                      _0: only$1
                    }
                  }
                },
                _2: match$8[1]
              };
      }
      var match$10 = uncons(match$1._0);
      var match$11 = unsnoc(match$1._2);
      var d1$1 = no_pref(match$1._1, match._1);
      var only_1$2 = {
        TAG: /* Only_red */4,
        _0: match$10[1],
        _1: d1$1,
        _2: match$11[0]
      };
      var only$2 = /* Path */{
        _0: /* HOLE */0,
        _1: only_1$2
      };
      return {
              TAG: /* Sandwich */1,
              _0: match$10[0],
              _1: /* S */{
                _0: /* T */{
                  _0: {
                    TAG: /* Only_path */0,
                    _0: only$2
                  }
                }
              },
              _2: match$11[1]
            };
    }
  } else {
    var match$12 = uncons_green_left(param._0);
    var left = match$12[1];
    var match$13 = unsnoc_green_right(param._1);
    var right = match$13[0];
    var d1$2;
    if (left.TAG === /* Exact_6 */0) {
      var lst = left._0;
      if (right.TAG === /* Exact_6 */0) {
        var buf = cons6(right._0, Dequeue_internal$ReasonDeque.empty);
        var buf$1 = cons6(lst, buf);
        d1$2 = /* S */{
          _0: /* T */{
            _0: {
              TAG: /* Only_path */0,
              _0: /* Path */{
                _0: /* HOLE */0,
                _1: {
                  TAG: /* Only_prefix */0,
                  _0: buf$1
                }
              }
            }
          }
        };
      } else {
        d1$2 = semi_of_right(lst, right._0);
      }
    } else {
      var left$1 = left._0;
      d1$2 = right.TAG === /* Exact_6 */0 ? semi_of_left(left$1, right._0) : /* S */({
            _0: /* T */{
              _0: {
                TAG: /* Pair_green */1,
                _0: left$1,
                _1: right._0
              }
            }
          });
    }
    return {
            TAG: /* Sandwich */1,
            _0: match$12[0],
            _1: d1$2,
            _2: match$13[1]
          };
  }
}

function unsandwich_stored(d1) {
  var match = unsandwich_green(d1);
  if (match.TAG === /* Alone */0) {
    var x = match._0;
    if (x.TAG === /* Stored_prefix */0) {
      return {
              TAG: /* Unstored_alone */0,
              _0: x._0
            };
    } else {
      return {
              TAG: /* Unstored_sandwich */1,
              _0: x._0,
              _1: /* S */{
                _0: x._1
              },
              _2: x._2
            };
    }
  }
  var p2 = match._0;
  if (p2.TAG === /* Stored_prefix */0) {
    var s3 = match._2;
    var d1$1 = match._1;
    var p2$1 = p2._0;
    if (s3.TAG === /* Stored_prefix */0) {
      return {
              TAG: /* Unstored_sandwich */1,
              _0: p2$1,
              _1: d1$1,
              _2: s3._0
            };
    }
    var d1$2 = snoc_semi(d1$1, {
          TAG: /* Stored_prefix */0,
          _0: s3._0
        });
    var d1$3 = concat_semi(d1$2, /* S */{
          _0: s3._1
        });
    return {
            TAG: /* Unstored_sandwich */1,
            _0: p2$1,
            _1: d1$3,
            _2: s3._2
          };
  }
  var s3$1 = match._2;
  var d1$4 = match._1;
  var s2 = p2._2;
  var d2 = p2._1;
  var p2$2 = p2._0;
  if (s3$1.TAG === /* Stored_prefix */0) {
    var d1$5 = cons_semi({
          TAG: /* Stored_prefix */0,
          _0: s2
        }, d1$4);
    var d1$6 = concat_semi(/* S */{
          _0: d2
        }, d1$5);
    return {
            TAG: /* Unstored_sandwich */1,
            _0: p2$2,
            _1: d1$6,
            _2: s3$1._0
          };
  }
  var d1$7 = cons_semi({
        TAG: /* Stored_prefix */0,
        _0: s2
      }, d1$4);
  var d1$8 = snoc_semi(d1$7, {
        TAG: /* Stored_prefix */0,
        _0: s3$1._0
      });
  var d1$9 = concat_semi(/* S */{
        _0: d2
      }, d1$8);
  var d1$10 = concat_semi(d1$9, /* S */{
        _0: s3$1._1
      });
  return {
          TAG: /* Unstored_sandwich */1,
          _0: p2$2,
          _1: d1$10,
          _2: s3$1._2
        };
}

function only_small(p2, s2) {
  var match = has3p8(s2);
  if (match.TAG === /* Less_than_11 */0) {
    var t = snoc8(p2, match._0);
    var p2$1 = vector_fold_left(Dequeue_internal$ReasonDeque.snoc, t, match._1);
    return {
            TAG: /* Only_prefix */0,
            _0: p2$1
          };
  }
  var stored = {
    TAG: /* Stored_prefix */0,
    _0: triple(match._0, match._1, match._2)
  };
  var d1 = only_single(stored);
  return {
          TAG: /* Only_green */1,
          _0: p2,
          _1: d1,
          _2: match._3
        };
}

function only_green(p2, d2, s2) {
  var d2$1 = d2._0;
  if (d2$1) {
    return {
            TAG: /* Only_green */1,
            _0: p2,
            _1: d2$1._0,
            _2: s2
          };
  } else {
    return only_small(p2, s2);
  }
}

function ensure_green(t) {
  var match = color(t);
  if (!match) {
    return t;
  }
  if (typeof t !== "number") {
    switch (t.TAG | 0) {
      case /* Only_red */4 :
          var d1 = t._1;
          var match$1 = has8(t._0);
          var match$2 = has8(t._2);
          if (match$1.TAG === /* Less_than_8 */0) {
            var p1_lst = match$1._0;
            if (match$2.TAG === /* Less_than_8 */0) {
              var s1_lst = match$2._0;
              var center = unsandwich_stored(d1);
              if (center.TAG === /* Unstored_alone */0) {
                var center$1 = cons_5_vector(p1_lst, center._0);
                var center$2 = snoc_5_vector(center$1, s1_lst);
                return {
                        TAG: /* Only_prefix */0,
                        _0: center$2
                      };
              }
              var p2 = cons_5_vector(p1_lst, center._0);
              var s2 = snoc_5_vector(center._2, s1_lst);
              return only_green(p2, center._1, s2);
            }
            var match$3 = uncons_stored(d1);
            var p2$1 = cons_5_vector(p1_lst, match$3._0);
            return only_green(p2$1, match$3._1, match$2._0);
          }
          var p1 = match$1._0;
          if (match$2.TAG !== /* Less_than_8 */0) {
            return {
                    TAG: /* Only_green */1,
                    _0: p1,
                    _1: d1,
                    _2: match$2._0
                  };
          }
          var match$4 = unsnoc_stored(d1);
          var s2$1 = snoc_5_vector(match$4._0, match$2._0);
          return only_green(p1, match$4._1, s2$1);
      case /* Left_red */9 :
          var s1 = t._2;
          var d1$1 = t._1;
          var p1$1 = has8(t._0);
          if (p1$1.TAG !== /* Less_than_8 */0) {
            return {
                    TAG: /* Left_green */6,
                    _0: p1$1._0,
                    _1: d1$1,
                    _2: s1
                  };
          }
          var match$5 = uncons_stored(d1$1);
          var d1$2 = match$5._1._0;
          var p2$2 = cons_5_vector(p1$1._0, match$5._0);
          if (d1$2) {
            return {
                    TAG: /* Left_green */6,
                    _0: p2$2,
                    _1: d1$2._0,
                    _2: s1
                  };
          } else {
            return {
                    TAG: /* Left_small */5,
                    _0: p2$2,
                    _1: s1
                  };
          }
      case /* Right_red */14 :
          var d1$3 = t._1;
          var p1$2 = t._0;
          var s1$1 = has8(t._2);
          if (s1$1.TAG !== /* Less_than_8 */0) {
            return {
                    TAG: /* Right_green */11,
                    _0: p1$2,
                    _1: d1$3,
                    _2: s1$1._0
                  };
          }
          var match$6 = unsnoc_stored(d1$3);
          var d1$4 = match$6._1._0;
          var s2$2 = snoc_5_vector(match$6._0, s1$1._0);
          if (d1$4) {
            return {
                    TAG: /* Right_green */11,
                    _0: p1$2,
                    _1: d1$4._0,
                    _2: s2$2
                  };
          } else {
            return {
                    TAG: /* Right_small */10,
                    _0: p1$2,
                    _1: s2$2
                  };
          }
      
    }
  }
  
}

function ensure_green_path(param) {
  return /* Path */{
          _0: param._0,
          _1: ensure_green(param._1)
        };
}

function ensure_green_deque(p) {
  switch (p.TAG | 0) {
    case /* Only_path */0 :
        return {
                TAG: /* Only_path */0,
                _0: ensure_green_path(p._0)
              };
    case /* Pair_green */1 :
        return {
                TAG: /* Pair_red */2,
                _0: ensure_green_path(p._0),
                _1: ensure_green_path(p._1)
              };
    case /* Pair_red */2 :
        return {
                TAG: /* Pair_red */2,
                _0: p._0,
                _1: p._1
              };
    
  }
}

function regular_of_semi(param) {
  var deq = param._0;
  if (deq) {
    return /* Regular */{
            _0: /* T */{
              _0: ensure_green_deque(deq._0)
            }
          };
  } else {
    return /* Regular */{
            _0: /* Void */0
          };
  }
}

function uncons$1(t) {
  var t$1 = t._0;
  if (!t$1) {
    return ;
  }
  var match = uncons_green(t$1._0);
  var reg = regular_of_semi(match[1]);
  return [
          match[0],
          reg
        ];
}

function unsnoc$1(t) {
  var t$1 = t._0;
  if (!t$1) {
    return ;
  }
  var match = unsnoc_green(t$1._0);
  return [
          regular_of_semi(match[0]),
          match[1]
        ];
}

var Deq;

var empty = /* Regular */{
  _0: /* Void */0
};

export {
  Deq ,
  vector_fold_right ,
  vector_fold_left ,
  $$Buffer ,
  empty ,
  is_empty ,
  cons_only_triple ,
  snoc_only_triple ,
  is_hole ,
  cons_only_path ,
  snoc_only_path ,
  cons_left_triple ,
  snoc_right_triple ,
  cons_left_path ,
  snoc_right_path ,
  cons_deque ,
  snoc_deque ,
  single_triple ,
  only_single ,
  single$1 as single,
  cons_t ,
  snoc_t ,
  cons$1 as cons,
  snoc$1 as snoc,
  cons_semi ,
  snoc_semi ,
  cons_vector$1 as cons_vector,
  snoc_vector$1 as snoc_vector,
  cons_semi_vector ,
  snoc_semi_vector ,
  color ,
  color_path ,
  color_deque ,
  color_st ,
  pref_left ,
  pref_right ,
  no_pref ,
  make_child ,
  cons_child ,
  snoc_child ,
  stored_left ,
  stored_right ,
  extract_stored_left ,
  extract_stored_right ,
  left_of_pair ,
  right_of_pair ,
  left_of_only ,
  right_of_only ,
  make_left ,
  make_right ,
  concat_semi ,
  concat ,
  semi_of_left ,
  semi_of_right ,
  uncons_green_left ,
  unsnoc_green_right ,
  uncons_green ,
  unsnoc_green ,
  uncons_stored ,
  unsnoc_stored ,
  unsandwich_green ,
  unsandwich_stored ,
  only_small ,
  only_green ,
  ensure_green ,
  ensure_green_path ,
  ensure_green_deque ,
  regular_of_semi ,
  uncons$1 as uncons,
  unsnoc$1 as unsnoc,
  
}
/* No side effect */
