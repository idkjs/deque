// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Seq from "./Seq.bs.js";
import * as List from "./List.bs.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Caml_exceptions from "bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";

function Make(D) {
  var hd = function (t) {
    var match = Curry._1(D.uncons, t);
    if (match !== undefined) {
      return match[0];
    } else {
      return Pervasives.failwith("Deque.hd");
    }
  };
  var tl = function (t) {
    var match = Curry._1(D.uncons, t);
    if (match !== undefined) {
      return match[1];
    } else {
      return Pervasives.failwith("Deque.tl");
    }
  };
  var iter = function (f, t) {
    return Curry._3(D.fold_left, (function (param, x) {
                  return Curry._1(f, x);
                }), undefined, t);
  };
  var iteri = function (f, t) {
    Curry._3(D.fold_left, (function (i, x) {
            Curry._2(f, i, x);
            return i + 1 | 0;
          }), 0, t);
    
  };
  var nth = function (t, idx) {
    if (idx < 0) {
      Pervasives.invalid_arg("Deque.nth");
    }
    var Found = /* @__PURE__ */Caml_exceptions.create("Found");
    try {
      iteri((function (i, x) {
              if (i !== idx) {
                return ;
              }
              throw {
                    RE_EXN_ID: Found,
                    _1: x,
                    Error: new Error()
                  };
            }), t);
      return Pervasives.failwith("Deque.nth");
    }
    catch (raw_x){
      var x = Caml_js_exceptions.internalToOCamlException(raw_x);
      if (x.RE_EXN_ID === Found) {
        return x._1;
      }
      throw x;
    }
  };
  var nth_opt = function (t, idx) {
    try {
      return Caml_option.some(nth(t, idx));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Failure") {
        return ;
      }
      throw exn;
    }
  };
  var map = function (f, t) {
    return Curry._3(D.fold_left, (function (ys, x) {
                  return Curry._2(D.snoc, ys, Curry._1(f, x));
                }), D.empty, t);
  };
  var mapi = function (f, t) {
    return Curry._3(D.fold_left, (function (param, x) {
                    var i = param[0];
                    return [
                            i + 1 | 0,
                            Curry._2(D.snoc, param[1], Curry._2(f, i, x))
                          ];
                  }), [
                  0,
                  D.empty
                ], t)[1];
  };
  var rev_map = function (f, t) {
    return Curry._3(D.fold_left, (function (ys, x) {
                  return Curry._2(D.cons, Curry._1(f, x), ys);
                }), D.empty, t);
  };
  var filter_map = function (f, t) {
    return Curry._3(D.fold_left, (function (ys, x) {
                  var y = Curry._1(f, x);
                  if (y !== undefined) {
                    return Curry._2(D.snoc, ys, Caml_option.valFromOption(y));
                  } else {
                    return ys;
                  }
                }), D.empty, t);
  };
  var fold_left_map = function (f, z, t) {
    return Curry._3(D.fold_left, (function (param, x) {
                  var match = Curry._2(f, param[0], x);
                  return [
                          match[0],
                          Curry._2(D.snoc, param[1], match[1])
                        ];
                }), [
                z,
                D.empty
              ], t);
  };
  var Abort = /* @__PURE__ */Caml_exceptions.create("List_like.Make(D).Abort");
  var exists = function (p, t) {
    try {
      iter((function (x) {
              if (!Curry._1(p, x)) {
                return ;
              }
              throw {
                    RE_EXN_ID: Abort,
                    Error: new Error()
                  };
            }), t);
      return false;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Abort) {
        return true;
      }
      throw exn;
    }
  };
  var for_all = function (p, t) {
    return !exists((function (x) {
                  return !Curry._1(p, x);
                }), t);
  };
  var mem = function (x, t) {
    return exists((function (param) {
                  return Caml_obj.caml_equal(x, param);
                }), t);
  };
  var memq = function (x, t) {
    return exists((function (param) {
                  return x === param;
                }), t);
  };
  var find = function (p, t) {
    var Found = /* @__PURE__ */Caml_exceptions.create("Found");
    try {
      iter((function (x) {
              if (!Curry._1(p, x)) {
                return ;
              }
              throw {
                    RE_EXN_ID: Found,
                    _1: x,
                    Error: new Error()
                  };
            }), t);
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    catch (raw_x){
      var x = Caml_js_exceptions.internalToOCamlException(raw_x);
      if (x.RE_EXN_ID === Found) {
        return x._1;
      }
      throw x;
    }
  };
  var find_opt = function (p, t) {
    var Found = /* @__PURE__ */Caml_exceptions.create("Found");
    try {
      iter((function (x) {
              if (!Curry._1(p, x)) {
                return ;
              }
              throw {
                    RE_EXN_ID: Found,
                    _1: x,
                    Error: new Error()
                  };
            }), t);
      return ;
    }
    catch (raw_x){
      var x = Caml_js_exceptions.internalToOCamlException(raw_x);
      if (x.RE_EXN_ID === Found) {
        return Caml_option.some(x._1);
      }
      throw x;
    }
  };
  var find_map = function (f, t) {
    var Found = /* @__PURE__ */Caml_exceptions.create("Found");
    var g = function (x) {
      var y = Curry._1(f, x);
      if (y === undefined) {
        return ;
      }
      throw {
            RE_EXN_ID: Found,
            _1: Caml_option.valFromOption(y),
            Error: new Error()
          };
    };
    try {
      iter(g, t);
      return ;
    }
    catch (raw_x){
      var x = Caml_js_exceptions.internalToOCamlException(raw_x);
      if (x.RE_EXN_ID === Found) {
        return Caml_option.some(x._1);
      }
      throw x;
    }
  };
  var filter = function (f, t) {
    return Curry._3(D.fold_left, (function (ys, x) {
                  if (Curry._1(f, x)) {
                    return Curry._2(D.snoc, ys, x);
                  } else {
                    return ys;
                  }
                }), D.empty, t);
  };
  var filteri = function (f, t) {
    return Curry._3(D.fold_left, (function (param, x) {
                    var ys = param[1];
                    var i = param[0];
                    return [
                            i + 1 | 0,
                            Curry._2(f, i, x) ? Curry._2(D.snoc, ys, x) : ys
                          ];
                  }), [
                  0,
                  D.empty
                ], t)[1];
  };
  var partition = function (f, t) {
    return Curry._3(D.fold_left, (function (param, x) {
                  var right = param[1];
                  var left = param[0];
                  if (Curry._1(f, x)) {
                    return [
                            Curry._2(D.snoc, left, x),
                            right
                          ];
                  } else {
                    return [
                            left,
                            Curry._2(D.snoc, right, x)
                          ];
                  }
                }), [
                D.empty,
                D.empty
              ], t);
  };
  var assoc = function (k, t) {
    return find((function (param) {
                    return Caml_obj.caml_equal(param[0], k);
                  }), t)[1];
  };
  var assoc_opt = function (k, t) {
    return find_map((function (param) {
                  if (Caml_obj.caml_equal(param[0], k)) {
                    return Caml_option.some(param[1]);
                  }
                  
                }), t);
  };
  var assq = function (k, t) {
    return find((function (param) {
                    return param[0] === k;
                  }), t)[1];
  };
  var assq_opt = function (k, t) {
    return find_map((function (param) {
                  if (param[0] === k) {
                    return Caml_option.some(param[1]);
                  }
                  
                }), t);
  };
  var mem_assoc = function (x, t) {
    return exists((function (param) {
                  return Caml_obj.caml_equal(x, param[0]);
                }), t);
  };
  var mem_assq = function (x, t) {
    return exists((function (param) {
                  return x === param[0];
                }), t);
  };
  var split = function (t) {
    return Curry._3(D.fold_left, (function (param, param$1) {
                  return [
                          Curry._2(D.snoc, param[0], param$1[0]),
                          Curry._2(D.snoc, param[1], param$1[1])
                        ];
                }), [
                D.empty,
                D.empty
              ], t);
  };
  var to_list = function (t) {
    return Curry._3(D.fold_right, (function (x, xs) {
                  return {
                          hd: x,
                          tl: xs
                        };
                }), t, /* [] */0);
  };
  var of_list = function (xs) {
    return List.fold_left((function (t, x) {
                  return Curry._2(D.snoc, t, x);
                }), D.empty, xs);
  };
  var to_seq = function (t) {
    return function (param) {
      return Seq.unfold(D.uncons, t, param);
    };
  };
  var of_seq = function (s) {
    return Seq.fold_left((function (xs, x) {
                  return Curry._2(D.snoc, xs, x);
                }), D.empty, s);
  };
  var init = function (n, f) {
    var _acc = D.empty;
    var _i = 0;
    while(true) {
      var i = _i;
      var acc = _acc;
      if (i >= n) {
        return acc;
      }
      var x = Curry._1(f, i);
      _i = i + 1 | 0;
      _acc = Curry._2(D.snoc, acc, x);
      continue ;
    };
  };
  var to_array = function (t) {
    var match = Curry._1(D.uncons, t);
    if (match === undefined) {
      return [];
    }
    var t$1 = match[1];
    var n = Curry._1(D.length, t$1);
    var arr = Caml_array.caml_make_vect(n + 1 | 0, match[0]);
    iteri((function (i, x) {
            return Caml_array.set(arr, i + 1 | 0, x);
          }), t$1);
    return arr;
  };
  var of_array = function (t) {
    return init(t.length, (function (param) {
                  return Caml_array.get(t, param);
                }));
  };
  var merge_head = function (cmp, acc, x, xs, y, ys) {
    if (Curry._2(cmp, x, y) <= 0) {
      return merge_right(cmp, Curry._2(D.snoc, acc, x), xs, y, ys);
    } else {
      return merge_left(cmp, Curry._2(D.snoc, acc, y), x, xs, ys);
    }
  };
  var merge_left = function (cmp, acc, x, xs, ys) {
    var match = Curry._1(D.uncons, ys);
    if (match !== undefined) {
      return merge_head(cmp, acc, x, xs, match[0], match[1]);
    } else {
      return Curry._2(D.append, Curry._2(D.snoc, acc, x), xs);
    }
  };
  var merge_right = function (cmp, acc, xs, y, ys) {
    var match = Curry._1(D.uncons, xs);
    if (match !== undefined) {
      return merge_head(cmp, acc, match[0], match[1], y, ys);
    } else {
      return Curry._2(D.append, Curry._2(D.snoc, acc, y), ys);
    }
  };
  var merge = function (cmp, xs, ys) {
    var acc = D.empty;
    var match = Curry._1(D.uncons, xs);
    if (match !== undefined) {
      return merge_left(cmp, acc, match[0], match[1], ys);
    } else {
      return Curry._2(D.append, acc, ys);
    }
  };
  var sort = function (cmp, t) {
    var t$1 = to_array(t);
    $$Array.sort(cmp, t$1);
    return of_array(t$1);
  };
  var stable_sort = function (cmp, t) {
    var t$1 = to_array(t);
    $$Array.stable_sort(cmp, t$1);
    return of_array(t$1);
  };
  var fast_sort = function (cmp, t) {
    var t$1 = to_array(t);
    $$Array.fast_sort(cmp, t$1);
    return of_array(t$1);
  };
  var sort_uniq = function (cmp, t) {
    return of_list(List.sort_uniq(cmp, to_list(t)));
  };
  var fold_left2 = function (exn, f, z, xs, ys) {
    var match = Curry._3(D.fold_left, (function (param, x) {
            var match = Curry._1(D.uncons, param[1]);
            if (match !== undefined) {
              return [
                      Curry._3(f, param[0], x, match[0]),
                      match[1]
                    ];
            }
            throw exn;
          }), [
          z,
          ys
        ], xs);
    if (Curry._1(D.is_empty, match[1])) {
      return match[0];
    }
    throw exn;
  };
  var iter2 = function (f, xs, ys) {
    return fold_left2({
                RE_EXN_ID: "Invalid_argument",
                _1: "Deque.iter2"
              }, (function (param, x, y) {
                  return Curry._2(f, x, y);
                }), undefined, xs, ys);
  };
  var map2 = function (f, xs, ys) {
    return fold_left2({
                RE_EXN_ID: "Invalid_argument",
                _1: "Deque.map2"
              }, (function (t, x, y) {
                  return Curry._2(D.snoc, t, Curry._2(f, x, y));
                }), D.empty, xs, ys);
  };
  var rev_map2 = function (f, xs, ys) {
    return fold_left2({
                RE_EXN_ID: "Invalid_argument",
                _1: "Deque.rev_map2"
              }, (function (t, x, y) {
                  return Curry._2(D.cons, Curry._2(f, x, y), t);
                }), D.empty, xs, ys);
  };
  var exists2 = function (p, xs, ys) {
    try {
      return fold_left2({
                  RE_EXN_ID: "Invalid_argument",
                  _1: "Deque.exists2"
                }, (function (b, x, y) {
                    if (Curry._2(p, x, y)) {
                      throw {
                            RE_EXN_ID: Abort,
                            Error: new Error()
                          };
                    }
                    return b;
                  }), false, xs, ys);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Abort) {
        return true;
      }
      throw exn;
    }
  };
  var for_all2 = function (p, xs, ys) {
    try {
      return fold_left2({
                  RE_EXN_ID: "Invalid_argument",
                  _1: "Deque.for_all2"
                }, (function (b, x, y) {
                    if (Curry._2(p, x, y)) {
                      return b;
                    }
                    throw {
                          RE_EXN_ID: Abort,
                          Error: new Error()
                        };
                  }), true, xs, ys);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Abort) {
        return false;
      }
      throw exn;
    }
  };
  var combine = function (xs, ys) {
    return fold_left2({
                RE_EXN_ID: "Invalid_argument",
                _1: "Deque.combine"
              }, (function (t, x, y) {
                  return Curry._2(D.snoc, t, [
                              x,
                              y
                            ]);
                }), D.empty, xs, ys);
  };
  var fold_left2$1 = function (f, z, xs, ys) {
    return fold_left2({
                RE_EXN_ID: "Invalid_argument",
                _1: "Deque.fold_left2"
              }, f, z, xs, ys);
  };
  var compare = function (cmp, xs, ys) {
    var Return = /* @__PURE__ */Caml_exceptions.create("Return");
    try {
      var ys$1 = Curry._3(D.fold_left, (function (ys, x) {
              var match = Curry._1(D.uncons, ys);
              if (match !== undefined) {
                var n = Curry._2(cmp, x, match[0]);
                if (n !== 0) {
                  throw {
                        RE_EXN_ID: Return,
                        _1: n,
                        Error: new Error()
                      };
                }
                return match[1];
              }
              throw {
                    RE_EXN_ID: Return,
                    _1: -1,
                    Error: new Error()
                  };
            }), ys, xs);
      if (Curry._1(D.is_empty, ys$1)) {
        return 0;
      } else {
        return 1;
      }
    }
    catch (raw_n){
      var n = Caml_js_exceptions.internalToOCamlException(raw_n);
      if (n.RE_EXN_ID === Return) {
        return n._1;
      }
      throw n;
    }
  };
  var equal = function (eq, xs, ys) {
    try {
      return Curry._1(D.is_empty, Curry._3(D.fold_left, (function (ys, x) {
                        var match = Curry._1(D.uncons, ys);
                        if (match !== undefined) {
                          if (Curry._2(eq, x, match[0])) {
                            return match[1];
                          }
                          throw {
                                RE_EXN_ID: Abort,
                                Error: new Error()
                              };
                        }
                        throw {
                              RE_EXN_ID: Abort,
                              Error: new Error()
                            };
                      }), ys, xs));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Abort) {
        return false;
      }
      throw exn;
    }
  };
  var $eq = function (xs, ys) {
    return equal(Caml_obj.caml_equal, xs, ys);
  };
  var $at = D.append;
  var rev_append = function (xs, ys) {
    return Curry._2($at, Curry._1(D.rev, xs), ys);
  };
  var concat = function (xss) {
    return Curry._3(D.fold_left, (function (z, x) {
                  return Curry._2($at, x, z);
                }), D.empty, xss);
  };
  var concat_map = function (f, t) {
    return Curry._3(D.fold_left, (function (ys, x) {
                  return Curry._2($at, ys, Curry._1(f, x));
                }), D.empty, t);
  };
  return {
          hd: hd,
          tl: tl,
          iter: iter,
          iteri: iteri,
          nth: nth,
          nth_opt: nth_opt,
          map: map,
          mapi: mapi,
          rev_map: rev_map,
          filter_map: filter_map,
          fold_left_map: fold_left_map,
          Abort: Abort,
          exists: exists,
          for_all: for_all,
          mem: mem,
          memq: memq,
          find: find,
          find_opt: find_opt,
          find_map: find_map,
          filter: filter,
          find_all: filter,
          filteri: filteri,
          partition: partition,
          assoc: assoc,
          assoc_opt: assoc_opt,
          assq: assq,
          assq_opt: assq_opt,
          mem_assoc: mem_assoc,
          mem_assq: mem_assq,
          split: split,
          to_list: to_list,
          of_list: of_list,
          to_seq: to_seq,
          of_seq: of_seq,
          init: init,
          to_array: to_array,
          of_array: of_array,
          merge_left: merge_left,
          merge_right: merge_right,
          merge_head: merge_head,
          merge: merge,
          sort: sort,
          stable_sort: stable_sort,
          fast_sort: fast_sort,
          sort_uniq: sort_uniq,
          iter2: iter2,
          map2: map2,
          rev_map2: rev_map2,
          exists2: exists2,
          for_all2: for_all2,
          combine: combine,
          fold_left2: fold_left2$1,
          compare: compare,
          equal: equal,
          $eq: $eq,
          $at: $at,
          rev_append: rev_append,
          concat: concat,
          flatten: concat,
          concat_map: concat_map
        };
}

export {
  Make ,
  
}
/* No side effect */
