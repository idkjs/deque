// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Dequeue = require("./dequeue.bs.js");
var Steque_internal = require("./steque_internal.bs.js");

var append = Steque_internal.concat;

function fold_left(f, z, t) {
  var fold_prefix = function (f, z, p) {
    switch (p.TAG | 0) {
      case /* P2 */0 :
          return Curry._2(f, Curry._2(f, z, p._0), p._1);
      case /* P3 */1 :
          return Curry._2(f, Curry._2(f, Curry._2(f, z, p._0), p._1), p._2);
      case /* P4 */2 :
          var z$1 = Curry._2(f, Curry._2(f, Curry._2(f, Curry._2(f, z, p._0), p._1), p._2), p._3);
          return Dequeue.fold_left(f, z$1, p._4);
      
    }
  };
  var go = function (f, z, steque, kont) {
    if (!steque) {
      return go_kont(f, z, kont);
    }
    var z$1 = fold_prefix(f, z, steque._0);
    var z$2 = go((function (param, param$1) {
            return go_pair(f, param, param$1);
          }), z$1, steque._1, kont);
    return Dequeue.fold_left(f, z$2, steque._2);
  };
  var go_pair = function (f, z, param) {
    var z$1 = fold_prefix(f, z, param._0);
    return go_kont((function (param, param$1) {
                  return go_pair(f, param, param$1);
                }), z$1, param._1);
  };
  var go_kont = function (f, z, kont) {
    if (kont.TAG === /* Suffix */0) {
      return Dequeue.fold_left(f, z, kont._0);
    } else {
      return go(f, z, kont._0, kont._1);
    }
  };
  return go_kont(f, z, t._0);
}

function fold_right(f, t, z) {
  var fold_prefix = function (f, p, z) {
    switch (p.TAG | 0) {
      case /* P2 */0 :
          return Curry._2(f, p._0, Curry._2(f, p._1, z));
      case /* P3 */1 :
          return Curry._2(f, p._0, Curry._2(f, p._1, Curry._2(f, p._2, z)));
      case /* P4 */2 :
          var z$1 = Dequeue.fold_right(f, p._4, z);
          return Curry._2(f, p._0, Curry._2(f, p._1, Curry._2(f, p._2, Curry._2(f, p._3, z$1))));
      
    }
  };
  var go = function (f, steque, z, kont) {
    if (!steque) {
      return go_kont(f, kont, z);
    }
    var z$1 = Dequeue.fold_right(f, steque._2, z);
    var z$2 = go((function (param, param$1) {
            return go_pair(f, param, param$1);
          }), steque._1, z$1, kont);
    return fold_prefix(f, steque._0, z$2);
  };
  var go_pair = function (f, param, z) {
    var z$1 = go_kont((function (param, param$1) {
            return go_pair(f, param, param$1);
          }), param._1, z);
    return fold_prefix(f, param._0, z$1);
  };
  var go_kont = function (f, kont, z) {
    if (kont.TAG === /* Suffix */0) {
      return Dequeue.fold_right(f, kont._0, z);
    } else {
      return go(f, kont._0, z, kont._1);
    }
  };
  return go_kont(f, t._0, z);
}

function rev(t) {
  return fold_left((function (t, x) {
                return Steque_internal.cons(x, t);
              }), Steque_internal.empty, t);
}

function of_dequeue(d) {
  return /* T */{
          _0: {
            TAG: /* Suffix */0,
            _0: d
          }
        };
}

function make(n, x) {
  var d = Dequeue.make(n, x);
  return /* T */{
          _0: {
            TAG: /* Suffix */0,
            _0: d
          }
        };
}

function singleton(x) {
  var d = Dequeue.singleton(x);
  return /* T */{
          _0: {
            TAG: /* Suffix */0,
            _0: d
          }
        };
}

function length(t) {
  return fold_left((function (s, param) {
                return s + 1 | 0;
              }), 0, t);
}

var empty = Steque_internal.empty;

var is_empty = Steque_internal.is_empty;

var cons = Steque_internal.cons;

var uncons = Steque_internal.uncons;

var snoc = Steque_internal.snoc;

exports.empty = empty;
exports.is_empty = is_empty;
exports.singleton = singleton;
exports.cons = cons;
exports.uncons = uncons;
exports.snoc = snoc;
exports.append = append;
exports.rev = rev;
exports.length = length;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.of_dequeue = of_dequeue;
exports.make = make;
/* Dequeue Not a pure module */
