// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Dequeue = require("./dequeue.bs.js");
var Deck_internal = require("./deck_internal.bs.js");

var append = Deck_internal.concat;

function fold_triple_h(f, acc, triple, kont) {
  if (typeof triple === "number") {
    var exit = 0;
    if (typeof kont === "number") {
      exit = 1;
    } else {
      switch (kont.TAG | 0) {
        case /* Only_prefix */0 :
            return buffer_fold_left(f, acc, kont._0);
        case /* Left_small */5 :
        case /* Right_small */10 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          var acc$1 = buffer_fold_left(f, acc, kont._0);
          var acc$2 = fold_deque((function (param, param$1) {
                  return fold_stored_triple(f, param, param$1);
                }), acc$1, kont._1);
          return buffer_fold_left(f, acc$2, kont._2);
      case 2 :
          var acc$3 = buffer_fold_left(f, acc, kont._0);
          return buffer_fold_left(f, acc$3, kont._1);
      
    }
  }
  var acc$4 = buffer_fold_left(f, acc, triple._0);
  var acc$5 = fold_nedeque((function (param, param$1) {
          return fold_stored_triple(f, param, param$1);
        }), acc$4, triple._1, kont);
  return buffer_fold_left(f, acc$5, triple._2);
}

function fold_stored_triple(f, acc, stored) {
  if (stored.TAG === /* Stored_prefix */0) {
    return buffer_fold_left(f, acc, stored._0);
  }
  var acc$1 = buffer_fold_left(f, acc, stored._0);
  var acc$2 = fold_st((function (param, param$1) {
          return fold_stored_triple(f, param, param$1);
        }), acc$1, stored._1);
  return buffer_fold_left(f, acc$2, stored._2);
}

function fold_deque(f, acc, deq) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return fold_path(f, acc, deq._0);
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  var acc$1 = fold_path(f, acc, deq._0);
  return fold_path(f, acc$1, deq._1);
}

function buffer_fold_left(f, acc, t) {
  return Dequeue.fold_left(f, acc, Deck_internal.$$Buffer.to_dequeue(t));
}

function fold_path(f, acc, param) {
  return fold_triple_h(f, acc, param._0, param._1);
}

function fold_st(f, acc, t) {
  if (t) {
    return fold_deque(f, acc, t._0);
  } else {
    return acc;
  }
}

function fold_nedeque(f, acc, deq, kont) {
  switch (deq.TAG | 0) {
    case /* Only_of */0 :
        return fold_triple_h(f, acc, deq._0, kont);
    case /* Pair_left */1 :
        var acc$1 = fold_triple_h(f, acc, deq._0, kont);
        return fold_path(f, acc$1, deq._1);
    case /* Pair_right */2 :
        var acc$2 = fold_path(f, acc, deq._0);
        return fold_triple_h(f, acc$2, deq._1, kont);
    
  }
}

function fold_left(f, acc, t) {
  return fold_st(f, acc, t._0);
}

function buffer_fold_right(f, t, acc) {
  return Dequeue.fold_right(f, Deck_internal.$$Buffer.to_dequeue(t), acc);
}

function fold_stored_triple$1(f, stored, acc) {
  if (stored.TAG === /* Stored_prefix */0) {
    return buffer_fold_right(f, stored._0, acc);
  }
  var acc$1 = buffer_fold_right(f, stored._2, acc);
  var acc$2 = fold_st$1((function (param, param$1) {
          return fold_stored_triple$1(f, param, param$1);
        }), stored._1, acc$1);
  return buffer_fold_right(f, stored._0, acc$2);
}

function fold_nedeque$1(f, deq, kont, acc) {
  switch (deq.TAG | 0) {
    case /* Only_of */0 :
        return fold_triple_h$1(f, deq._0, kont, acc);
    case /* Pair_left */1 :
        var acc$1 = fold_path$1(f, deq._1, acc);
        return fold_triple_h$1(f, deq._0, kont, acc$1);
    case /* Pair_right */2 :
        var acc$2 = fold_triple_h$1(f, deq._1, kont, acc);
        return fold_path$1(f, deq._0, acc$2);
    
  }
}

function fold_deque$1(f, deq, acc) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return fold_path$1(f, deq._0, acc);
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  var acc$1 = fold_path$1(f, deq._1, acc);
  return fold_path$1(f, deq._0, acc$1);
}

function fold_triple_h$1(f, triple, kont, acc) {
  if (typeof triple === "number") {
    var exit = 0;
    if (typeof kont === "number") {
      exit = 1;
    } else {
      switch (kont.TAG | 0) {
        case /* Only_prefix */0 :
            return buffer_fold_right(f, kont._0, acc);
        case /* Left_small */5 :
        case /* Right_small */10 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          var acc$1 = buffer_fold_right(f, kont._2, acc);
          var acc$2 = fold_deque$1((function (param, param$1) {
                  return fold_stored_triple$1(f, param, param$1);
                }), kont._1, acc$1);
          return buffer_fold_right(f, kont._0, acc$2);
      case 2 :
          var acc$3 = buffer_fold_right(f, kont._1, acc);
          return buffer_fold_right(f, kont._0, acc$3);
      
    }
  }
  var acc$4 = buffer_fold_right(f, triple._2, acc);
  var acc$5 = fold_nedeque$1((function (param, param$1) {
          return fold_stored_triple$1(f, param, param$1);
        }), triple._1, kont, acc$4);
  return buffer_fold_right(f, triple._0, acc$5);
}

function fold_path$1(f, param, acc) {
  return fold_triple_h$1(f, param._0, param._1, acc);
}

function fold_st$1(f, t, acc) {
  if (t) {
    return fold_deque$1(f, t._0, acc);
  } else {
    return acc;
  }
}

function fold_right(f, t, acc) {
  return fold_st$1(f, t._0, acc);
}

function rev(t) {
  return fold_left((function (t, x) {
                return Deck_internal.cons(x, t);
              }), Deck_internal.empty, t);
}

function of_dequeue(d) {
  var d$1 = Deck_internal.$$Buffer.of_dequeue(d);
  if (d$1) {
    return /* Regular */{
            _0: /* T */{
              _0: {
                TAG: /* Only_path */0,
                _0: /* Path */{
                  _0: /* HOLE */0,
                  _1: {
                    TAG: /* Only_prefix */0,
                    _0: d$1._0
                  }
                }
              }
            }
          };
  } else {
    return /* Regular */{
            _0: /* Void */0
          };
  }
}

function make(n, x) {
  return of_dequeue(Dequeue.make(n, x));
}

function singleton(x) {
  return of_dequeue(Dequeue.singleton(x));
}

function length(t) {
  return fold_left((function (s, param) {
                return s + 1 | 0;
              }), 0, t);
}

var empty = Deck_internal.empty;

var is_empty = Deck_internal.is_empty;

var cons = Deck_internal.cons;

var uncons = Deck_internal.uncons;

var snoc = Deck_internal.snoc;

var unsnoc = Deck_internal.unsnoc;

exports.empty = empty;
exports.is_empty = is_empty;
exports.singleton = singleton;
exports.cons = cons;
exports.uncons = uncons;
exports.snoc = snoc;
exports.unsnoc = unsnoc;
exports.append = append;
exports.rev = rev;
exports.length = length;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.of_dequeue = of_dequeue;
exports.make = make;
/* Dequeue Not a pure module */
