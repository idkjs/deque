// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("./List.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var List_like = require("./list_like.bs.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Dequeue_internal = require("./dequeue_internal.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function fold_left(f, z, t) {
  var list_of_buffer = function (f, z, buf) {
    if (typeof buf === "number") {
      return z;
    }
    switch (buf.TAG | 0) {
      case /* B1 */0 :
          return Curry._2(f, z, buf._0);
      case /* B2 */1 :
          return Curry._2(f, Curry._2(f, z, buf._0), buf._1);
      case /* B3 */2 :
          return Curry._2(f, Curry._2(f, Curry._2(f, z, buf._0), buf._1), buf._2);
      case /* B4 */3 :
          return Curry._2(f, Curry._2(f, Curry._2(f, Curry._2(f, z, buf._0), buf._1), buf._2), buf._3);
      case /* B5 */4 :
          return Curry._2(f, Curry._2(f, Curry._2(f, Curry._2(f, Curry._2(f, z, buf._0), buf._1), buf._2), buf._3), buf._4);
      
    }
  };
  var go = function (f, z, deq, kont) {
    if (typeof deq === "number") {
      return go_kont(f, z, kont);
    }
    var z$1 = list_of_buffer(f, z, deq._0);
    var z$2 = go((function (param, param$1) {
            return Curry._2(f, Curry._2(f, param, param$1[0]), param$1[1]);
          }), z$1, deq._1, kont);
    return list_of_buffer(f, z$2, deq._2);
  };
  var go_kont = function (f, z, kont) {
    if (kont.TAG === /* Small */0) {
      return list_of_buffer(f, z, kont._0);
    } else {
      return go(f, z, kont._0, kont._1);
    }
  };
  return go_kont(f, z, t._0);
}

function fold_right(f, t, z) {
  var list_of_buffer = function (f, buf, z) {
    if (typeof buf === "number") {
      return z;
    }
    switch (buf.TAG | 0) {
      case /* B1 */0 :
          return Curry._2(f, buf._0, z);
      case /* B2 */1 :
          return Curry._2(f, buf._0, Curry._2(f, buf._1, z));
      case /* B3 */2 :
          return Curry._2(f, buf._0, Curry._2(f, buf._1, Curry._2(f, buf._2, z)));
      case /* B4 */3 :
          return Curry._2(f, buf._0, Curry._2(f, buf._1, Curry._2(f, buf._2, Curry._2(f, buf._3, z))));
      case /* B5 */4 :
          return Curry._2(f, buf._0, Curry._2(f, buf._1, Curry._2(f, buf._2, Curry._2(f, buf._3, Curry._2(f, buf._4, z)))));
      
    }
  };
  var go = function (f, deq, z, kont) {
    if (typeof deq === "number") {
      return go_kont(f, kont, z);
    }
    var z$1 = list_of_buffer(f, deq._2, z);
    var z$2 = go((function (param, param$1) {
            return Curry._2(f, param[0], Curry._2(f, param[1], param$1));
          }), deq._1, z$1, kont);
    return list_of_buffer(f, deq._0, z$2);
  };
  var go_kont = function (f, kont, z) {
    if (kont.TAG === /* Small */0) {
      return list_of_buffer(f, kont._0, z);
    } else {
      return go(f, kont._0, z, kont._1);
    }
  };
  return go_kont(f, t._0, z);
}

function fold_left$1(f, z, param) {
  var s = param.s;
  if (param.length >= 0) {
    return fold_left(f, z, s);
  } else {
    return fold_right((function (x, z) {
                  return Curry._2(f, z, x);
                }), s, z);
  }
}

function fold_right$1(f, param, z) {
  var s = param.s;
  if (param.length >= 0) {
    return fold_right(f, s, z);
  } else {
    return fold_left((function (x, z) {
                  return Curry._2(f, z, x);
                }), z, s);
  }
}

function compare_lengths(xs, ys) {
  return Caml_primitive.caml_int_compare(Dequeue_internal.length(xs), Dequeue_internal.length(ys));
}

function append(xs, ys) {
  if (compare_lengths(xs, ys) <= 0) {
    return fold_right$1(Dequeue_internal.cons, xs, ys);
  } else {
    return fold_left$1(Dequeue_internal.snoc, xs, ys);
  }
}

var Base = {
  green_prefix_cons: Dequeue_internal.green_prefix_cons,
  green_suffix_snoc: Dequeue_internal.green_suffix_snoc,
  yellow_prefix_cons: Dequeue_internal.yellow_prefix_cons,
  yellow_suffix_snoc: Dequeue_internal.yellow_suffix_snoc,
  buffer_cons: Dequeue_internal.buffer_cons,
  buffer_snoc: Dequeue_internal.buffer_snoc,
  green_uncons: Dequeue_internal.green_uncons,
  green_unsnoc: Dequeue_internal.green_unsnoc,
  yellow_uncons: Dequeue_internal.yellow_uncons,
  yellow_unsnoc: Dequeue_internal.yellow_unsnoc,
  buffer_uncons_unsafe: Dequeue_internal.buffer_uncons_unsafe,
  buffer_unsnoc_unsafe: Dequeue_internal.buffer_unsnoc_unsafe,
  buffer_uncons: Dequeue_internal.buffer_uncons,
  buffer_unsnoc: Dequeue_internal.buffer_unsnoc,
  prefix_rot: Dequeue_internal.prefix_rot,
  suffix_rot: Dequeue_internal.suffix_rot,
  prefix_decompose: Dequeue_internal.prefix_decompose,
  suffix_decompose: Dequeue_internal.suffix_decompose,
  prefix23: Dequeue_internal.prefix23,
  suffix23: Dequeue_internal.suffix23,
  prefix12: Dequeue_internal.prefix12,
  green_prefix_concat: Dequeue_internal.green_prefix_concat,
  green_suffix_concat: Dequeue_internal.green_suffix_concat,
  prefix_concat: Dequeue_internal.prefix_concat,
  suffix_concat: Dequeue_internal.suffix_concat,
  buffer_unsandwich: Dequeue_internal.buffer_unsandwich,
  buffer_halve: Dequeue_internal.buffer_halve,
  make_small: Dequeue_internal.make_small,
  green_of_red: Dequeue_internal.green_of_red,
  ensure_green: Dequeue_internal.ensure_green,
  yellow: Dequeue_internal.yellow,
  red: Dequeue_internal.red,
  uncons_unsafe: Dequeue_internal.uncons_unsafe,
  unsnoc_unsafe: Dequeue_internal.unsnoc_unsafe,
  empty: Dequeue_internal.empty,
  is_empty: Dequeue_internal.is_empty,
  length: Dequeue_internal.length,
  rev: Dequeue_internal.rev,
  cons: Dequeue_internal.cons,
  snoc: Dequeue_internal.snoc,
  uncons: Dequeue_internal.uncons,
  unsnoc: Dequeue_internal.unsnoc,
  is_rev: Dequeue_internal.is_rev,
  fold_left: fold_left$1,
  fold_right: fold_right$1,
  compare_lengths: compare_lengths,
  append: append
};

var include = List_like.Make({
      empty: Dequeue_internal.empty,
      is_empty: Dequeue_internal.is_empty,
      cons: Dequeue_internal.cons,
      uncons: Dequeue_internal.uncons,
      snoc: Dequeue_internal.snoc,
      fold_left: fold_left$1,
      fold_right: fold_right$1,
      rev: Dequeue_internal.rev,
      append: append,
      length: Dequeue_internal.length
    });

function nth(t, i, j) {
  var buffer_length = function (s, param) {
    if (typeof param === "number") {
      return 0;
    }
    switch (param.TAG | 0) {
      case /* B1 */0 :
          return s;
      case /* B2 */1 :
          return (s << 1);
      case /* B3 */2 :
          return Math.imul(3, s);
      case /* B4 */3 :
          return (s << 2);
      case /* B5 */4 :
          return Math.imul(5, s);
      
    }
  };
  var buffer = function (i, s, search, a) {
    if (typeof a === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "dequeue.re",
              144,
              16
            ],
            Error: new Error()
          };
    }
    switch (a.TAG | 0) {
      case /* B1 */0 :
          return Curry._3(search, i, s, a._0);
      case /* B2 */1 :
          if (i < s) {
            return Curry._3(search, i, s, a._0);
          } else {
            return Curry._3(search, i - s | 0, s, a._1);
          }
      case /* B3 */2 :
          var match = Caml_int32.div(i, s);
          switch (match) {
            case 0 :
                return Curry._3(search, i, s, a._0);
            case 1 :
                return Curry._3(search, i - s | 0, s, a._1);
            case 2 :
                return Curry._3(search, i - (s << 1) | 0, s, a._2);
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "dequeue.re",
                      157,
                      17
                    ],
                    Error: new Error()
                  };
          }
      case /* B4 */3 :
          var match$1 = Caml_int32.div(i, s);
          switch (match$1) {
            case 0 :
                return Curry._3(search, i, s, a._0);
            case 1 :
                return Curry._3(search, i - s | 0, s, a._1);
            case 2 :
                return Curry._3(search, i - (s << 1) | 0, s, a._2);
            case 3 :
                return Curry._3(search, i - Math.imul(3, s) | 0, s, a._3);
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "dequeue.re",
                      165,
                      17
                    ],
                    Error: new Error()
                  };
          }
      case /* B5 */4 :
          var match$2 = Caml_int32.div(i, s);
          switch (match$2) {
            case 0 :
                return Curry._3(search, i, s, a._0);
            case 1 :
                return Curry._3(search, i - s | 0, s, a._1);
            case 2 :
                return Curry._3(search, i - (s << 1) | 0, s, a._2);
            case 3 :
                return Curry._3(search, i - Math.imul(3, s) | 0, s, a._3);
            case 4 :
                return Curry._3(search, i - (s << 2) | 0, s, a._4);
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "dequeue.re",
                      174,
                      17
                    ],
                    Error: new Error()
                  };
          }
      
    }
  };
  var go = function (i, j, s, search, deq, kont) {
    if (typeof deq === "number") {
      return go_kont(i, j, s, search, kont);
    } else {
      var prefix = deq._0;
      var suffix = deq._2;
      var child = deq._1;
      var prefix_len = buffer_length(s, prefix);
      var suffix_len = buffer_length(s, suffix);
      if (i < prefix_len) {
        return buffer(i, s, search, prefix);
      }
      if (j < suffix_len) {
        return buffer((suffix_len - j | 0) - 1 | 0, s, search, suffix);
      }
      var i$1 = i - prefix_len | 0;
      var j$1 = j - suffix_len | 0;
      var s$1 = (s << 1);
      return go(i$1, j$1, s$1, (function (param, param$1, param$2) {
                    var s2 = param$1 / 2 | 0;
                    if (param < s2) {
                      return Curry._3(search, param, s2, param$2[0]);
                    } else {
                      return Curry._3(search, param - s2 | 0, s2, param$2[1]);
                    }
                  }), child, kont);
    }
  };
  var go_kont = function (i, j, s, search, buf) {
    if (buf.TAG === /* Small */0) {
      return buffer(i, s, search, buf._0);
    } else {
      return go(i, j, s, search, buf._0, buf._1);
    }
  };
  var search1 = function (param, param$1, x) {
    return x;
  };
  return go_kont(i, j, 1, search1, t._0);
}

function nth$1(t, i) {
  if (i < 0) {
    Pervasives.invalid_arg("Dequeue.nth");
  }
  var j = (Dequeue_internal.length(t) - i | 0) - 1 | 0;
  if (j < 0) {
    Pervasives.failwith("Dequeue.nth");
  }
  if (t.length >= 0) {
    return nth(t.s, i, j);
  } else {
    return nth(t.s, j, i);
  }
}

function nth_opt(t, i) {
  try {
    return Caml_option.some(nth$1(t, i));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

function make(n, x) {
  switch (n) {
    case 0 :
        return {
                TAG: /* Small */0,
                _0: /* B0 */0
              };
    case 1 :
        return {
                TAG: /* Small */0,
                _0: {
                  TAG: /* B1 */0,
                  _0: x
                }
              };
    case 2 :
        return {
                TAG: /* Small */0,
                _0: {
                  TAG: /* B2 */1,
                  _0: x,
                  _1: x
                }
              };
    case 3 :
        return {
                TAG: /* Small */0,
                _0: {
                  TAG: /* B3 */2,
                  _0: x,
                  _1: x,
                  _2: x
                }
              };
    default:
      var n$1 = n - 4 | 0;
      var match = n$1 % 2;
      if (match !== 0) {
        if (match !== 1) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "dequeue.re",
                  293,
                  13
                ],
                Error: new Error()
              };
        }
        var p = {
          TAG: /* B3 */2,
          _0: x,
          _1: x,
          _2: x
        };
        var s = {
          TAG: /* B2 */1,
          _0: x,
          _1: x
        };
        var x2 = [
          x,
          x
        ];
        return {
                TAG: /* G */1,
                _0: {
                  TAG: /* Green */1,
                  _0: p,
                  _1: /* HOLE */0,
                  _2: s
                },
                _1: make((n$1 - 1 | 0) / 2 | 0, x2)
              };
      }
      var b = {
        TAG: /* B2 */1,
        _0: x,
        _1: x
      };
      var x2$1 = [
        x,
        x
      ];
      return {
              TAG: /* G */1,
              _0: {
                TAG: /* Green */1,
                _0: b,
                _1: /* HOLE */0,
                _2: b
              },
              _1: make(n$1 / 2 | 0, x2$1)
            };
  }
}

function make$1(n, x) {
  return {
          length: n,
          s: /* T */{
            _0: make(n, x)
          }
        };
}

function of_list(param) {
  if (!param) {
    return {
            TAG: /* Small */0,
            _0: /* B0 */0
          };
  }
  var match = param.tl;
  var a = param.hd;
  if (!match) {
    return {
            TAG: /* Small */0,
            _0: {
              TAG: /* B1 */0,
              _0: a
            }
          };
  }
  var match$1 = match.tl;
  var b = match.hd;
  if (!match$1) {
    return {
            TAG: /* Small */0,
            _0: {
              TAG: /* B2 */1,
              _0: a,
              _1: b
            }
          };
  }
  var match$2 = match$1.tl;
  var c = match$1.hd;
  if (!match$2) {
    return {
            TAG: /* Small */0,
            _0: {
              TAG: /* B3 */2,
              _0: a,
              _1: b,
              _2: c
            }
          };
  }
  var p = {
    TAG: /* B2 */1,
    _0: a,
    _1: b
  };
  var go = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      var match = param[2];
      var d = param[1];
      var c = param[0];
      if (!match) {
        return [
                acc,
                {
                  TAG: /* B2 */1,
                  _0: c,
                  _1: d
                }
              ];
      }
      var match$1 = match.tl;
      var e = match.hd;
      if (!match$1) {
        return [
                acc,
                {
                  TAG: /* B3 */2,
                  _0: c,
                  _1: d,
                  _2: e
                }
              ];
      }
      _param = [
        e,
        match$1.hd,
        match$1.tl
      ];
      _acc = {
        hd: [
          c,
          d
        ],
        tl: acc
      };
      continue ;
    };
  };
  var match$3 = go(/* [] */0, [
        c,
        match$2.hd,
        match$2.tl
      ]);
  return {
          TAG: /* G */1,
          _0: {
            TAG: /* Green */1,
            _0: p,
            _1: /* HOLE */0,
            _2: match$3[1]
          },
          _1: of_list(List.rev(match$3[0]))
        };
}

function of_list$1(lst) {
  return {
          length: List.length(lst),
          s: /* T */{
            _0: of_list(lst)
          }
        };
}

function singleton(x) {
  return {
          length: 1,
          s: /* T */{
            _0: {
              TAG: /* Small */0,
              _0: {
                TAG: /* B1 */0,
                _0: x
              }
            }
          }
        };
}

var hd = include.hd;

var tl = include.tl;

var iter = include.iter;

var iteri = include.iteri;

var map = include.map;

var mapi = include.mapi;

var rev_map = include.rev_map;

var filter_map = include.filter_map;

var fold_left_map = include.fold_left_map;

var Abort = include.Abort;

var exists = include.exists;

var for_all = include.for_all;

var mem = include.mem;

var memq = include.memq;

var find = include.find;

var find_opt = include.find_opt;

var find_map = include.find_map;

var filter = include.filter;

var find_all = include.find_all;

var filteri = include.filteri;

var partition = include.partition;

var assoc = include.assoc;

var assoc_opt = include.assoc_opt;

var assq = include.assq;

var assq_opt = include.assq_opt;

var mem_assoc = include.mem_assoc;

var mem_assq = include.mem_assq;

var split = include.split;

var to_list = include.to_list;

var to_seq = include.to_seq;

var of_seq = include.of_seq;

var init = include.init;

var to_array = include.to_array;

var of_array = include.of_array;

var merge_left = include.merge_left;

var merge_right = include.merge_right;

var merge_head = include.merge_head;

var merge = include.merge;

var sort = include.sort;

var stable_sort = include.stable_sort;

var fast_sort = include.fast_sort;

var sort_uniq = include.sort_uniq;

var iter2 = include.iter2;

var map2 = include.map2;

var rev_map2 = include.rev_map2;

var exists2 = include.exists2;

var for_all2 = include.for_all2;

var combine = include.combine;

var fold_left2 = include.fold_left2;

var compare = include.compare;

var equal = include.equal;

var $eq = include.$eq;

var $at = include.$at;

var rev_append = include.rev_append;

var concat = include.concat;

var flatten = include.flatten;

var concat_map = include.concat_map;

var green_prefix_cons = Dequeue_internal.green_prefix_cons;

var green_suffix_snoc = Dequeue_internal.green_suffix_snoc;

var yellow_prefix_cons = Dequeue_internal.yellow_prefix_cons;

var yellow_suffix_snoc = Dequeue_internal.yellow_suffix_snoc;

var buffer_cons = Dequeue_internal.buffer_cons;

var buffer_snoc = Dequeue_internal.buffer_snoc;

var green_uncons = Dequeue_internal.green_uncons;

var green_unsnoc = Dequeue_internal.green_unsnoc;

var yellow_uncons = Dequeue_internal.yellow_uncons;

var yellow_unsnoc = Dequeue_internal.yellow_unsnoc;

var buffer_uncons_unsafe = Dequeue_internal.buffer_uncons_unsafe;

var buffer_unsnoc_unsafe = Dequeue_internal.buffer_unsnoc_unsafe;

var buffer_uncons = Dequeue_internal.buffer_uncons;

var buffer_unsnoc = Dequeue_internal.buffer_unsnoc;

var prefix_rot = Dequeue_internal.prefix_rot;

var suffix_rot = Dequeue_internal.suffix_rot;

var prefix_decompose = Dequeue_internal.prefix_decompose;

var suffix_decompose = Dequeue_internal.suffix_decompose;

var prefix23 = Dequeue_internal.prefix23;

var suffix23 = Dequeue_internal.suffix23;

var prefix12 = Dequeue_internal.prefix12;

var green_prefix_concat = Dequeue_internal.green_prefix_concat;

var green_suffix_concat = Dequeue_internal.green_suffix_concat;

var prefix_concat = Dequeue_internal.prefix_concat;

var suffix_concat = Dequeue_internal.suffix_concat;

var buffer_unsandwich = Dequeue_internal.buffer_unsandwich;

var buffer_halve = Dequeue_internal.buffer_halve;

var make_small = Dequeue_internal.make_small;

var green_of_red = Dequeue_internal.green_of_red;

var ensure_green = Dequeue_internal.ensure_green;

var yellow = Dequeue_internal.yellow;

var red = Dequeue_internal.red;

var uncons_unsafe = Dequeue_internal.uncons_unsafe;

var unsnoc_unsafe = Dequeue_internal.unsnoc_unsafe;

var empty = Dequeue_internal.empty;

var is_empty = Dequeue_internal.is_empty;

var length = Dequeue_internal.length;

var rev = Dequeue_internal.rev;

var cons = Dequeue_internal.cons;

var snoc = Dequeue_internal.snoc;

var uncons = Dequeue_internal.uncons;

var unsnoc = Dequeue_internal.unsnoc;

var is_rev = Dequeue_internal.is_rev;

exports.Base = Base;
exports.hd = hd;
exports.tl = tl;
exports.iter = iter;
exports.iteri = iteri;
exports.map = map;
exports.mapi = mapi;
exports.rev_map = rev_map;
exports.filter_map = filter_map;
exports.fold_left_map = fold_left_map;
exports.Abort = Abort;
exports.exists = exists;
exports.for_all = for_all;
exports.mem = mem;
exports.memq = memq;
exports.find = find;
exports.find_opt = find_opt;
exports.find_map = find_map;
exports.filter = filter;
exports.find_all = find_all;
exports.filteri = filteri;
exports.partition = partition;
exports.assoc = assoc;
exports.assoc_opt = assoc_opt;
exports.assq = assq;
exports.assq_opt = assq_opt;
exports.mem_assoc = mem_assoc;
exports.mem_assq = mem_assq;
exports.split = split;
exports.to_list = to_list;
exports.to_seq = to_seq;
exports.of_seq = of_seq;
exports.init = init;
exports.to_array = to_array;
exports.of_array = of_array;
exports.merge_left = merge_left;
exports.merge_right = merge_right;
exports.merge_head = merge_head;
exports.merge = merge;
exports.sort = sort;
exports.stable_sort = stable_sort;
exports.fast_sort = fast_sort;
exports.sort_uniq = sort_uniq;
exports.iter2 = iter2;
exports.map2 = map2;
exports.rev_map2 = rev_map2;
exports.exists2 = exists2;
exports.for_all2 = for_all2;
exports.combine = combine;
exports.fold_left2 = fold_left2;
exports.compare = compare;
exports.equal = equal;
exports.$eq = $eq;
exports.$at = $at;
exports.rev_append = rev_append;
exports.concat = concat;
exports.flatten = flatten;
exports.concat_map = concat_map;
exports.green_prefix_cons = green_prefix_cons;
exports.green_suffix_snoc = green_suffix_snoc;
exports.yellow_prefix_cons = yellow_prefix_cons;
exports.yellow_suffix_snoc = yellow_suffix_snoc;
exports.buffer_cons = buffer_cons;
exports.buffer_snoc = buffer_snoc;
exports.green_uncons = green_uncons;
exports.green_unsnoc = green_unsnoc;
exports.yellow_uncons = yellow_uncons;
exports.yellow_unsnoc = yellow_unsnoc;
exports.buffer_uncons_unsafe = buffer_uncons_unsafe;
exports.buffer_unsnoc_unsafe = buffer_unsnoc_unsafe;
exports.buffer_uncons = buffer_uncons;
exports.buffer_unsnoc = buffer_unsnoc;
exports.prefix_rot = prefix_rot;
exports.suffix_rot = suffix_rot;
exports.prefix_decompose = prefix_decompose;
exports.suffix_decompose = suffix_decompose;
exports.prefix23 = prefix23;
exports.suffix23 = suffix23;
exports.prefix12 = prefix12;
exports.green_prefix_concat = green_prefix_concat;
exports.green_suffix_concat = green_suffix_concat;
exports.prefix_concat = prefix_concat;
exports.suffix_concat = suffix_concat;
exports.buffer_unsandwich = buffer_unsandwich;
exports.buffer_halve = buffer_halve;
exports.make_small = make_small;
exports.green_of_red = green_of_red;
exports.ensure_green = ensure_green;
exports.yellow = yellow;
exports.red = red;
exports.uncons_unsafe = uncons_unsafe;
exports.unsnoc_unsafe = unsnoc_unsafe;
exports.empty = empty;
exports.is_empty = is_empty;
exports.length = length;
exports.rev = rev;
exports.cons = cons;
exports.snoc = snoc;
exports.uncons = uncons;
exports.unsnoc = unsnoc;
exports.is_rev = is_rev;
exports.fold_left = fold_left$1;
exports.fold_right = fold_right$1;
exports.compare_lengths = compare_lengths;
exports.append = append;
exports.nth = nth$1;
exports.nth_opt = nth_opt;
exports.make = make$1;
exports.of_list = of_list$1;
exports.singleton = singleton;
/* include Not a pure module */
