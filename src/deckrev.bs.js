// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Dequeue = require("./dequeue.bs.js");
var Deckrev_internal = require("./deckrev_internal.bs.js");

var append = Deckrev_internal.concat;

function fold_left_st(f, acc, t) {
  if (typeof t === "number") {
    return acc;
  } else if (t.TAG === /* T */0) {
    return fold_left_deque(f, acc, t._0);
  } else {
    return fold_right_deque((function (x, z) {
                  return Curry._2(f, z, x);
                }), t._0, acc);
  }
}

function fold_right_nedeque(f, deq, kont, acc) {
  var exit = 0;
  switch (deq.TAG | 0) {
    case /* Only_of */0 :
        return fold_right_triple_h(f, deq._0, kont, acc);
    case /* Pair_right */2 :
    case /* Pair_left_sym */3 :
        exit = 2;
        break;
    case /* Pair_left */1 :
    case /* Pair_right_sym */4 :
        exit = 1;
        break;
    
  }
  switch (exit) {
    case 1 :
        var acc$1 = fold_right_path(f, deq._1, acc);
        return fold_right_triple_h(f, deq._0, kont, acc$1);
    case 2 :
        var acc$2 = fold_right_triple_h(f, deq._1, kont, acc);
        return fold_right_path(f, deq._0, acc$2);
    
  }
}

function fold_right_stored_triple(f, stored, acc) {
  var p = Deckrev_internal.stored_elt(stored);
  if (p.TAG === /* Stored_prefix */0) {
    return buffer_fold_right(f, p._0, acc);
  }
  var acc$1 = buffer_fold_right(f, p._2, acc);
  var acc$2 = fold_right_st((function (param, param$1) {
          return fold_right_stored_triple(f, param, param$1);
        }), p._1, acc$1);
  return buffer_fold_right(f, p._0, acc$2);
}

function buffer_fold_right(f, t, acc) {
  var deq = Deckrev_internal.$$Buffer.to_dequeue(t);
  return Dequeue.fold_right((function (x, z) {
                return Curry._2(f, Deckrev_internal.$$Buffer.elt_out(x, t), z);
              }), deq, acc);
}

function fold_right_path(f, param, acc) {
  return fold_right_triple_h(f, param._0, param._1, acc);
}

function fold_left_stored_triple(f, acc, stored) {
  var p = Deckrev_internal.stored_elt(stored);
  if (p.TAG === /* Stored_prefix */0) {
    return buffer_fold_left(f, acc, p._0);
  }
  var acc$1 = buffer_fold_left(f, acc, p._0);
  var acc$2 = fold_left_st((function (param, param$1) {
          return fold_left_stored_triple(f, param, param$1);
        }), acc$1, p._1);
  return buffer_fold_left(f, acc$2, p._2);
}

function buffer_fold_left(f, acc, t) {
  var deq = Deckrev_internal.$$Buffer.to_dequeue(t);
  return Dequeue.fold_left((function (z, x) {
                return Curry._2(f, z, Deckrev_internal.$$Buffer.elt_out(x, t));
              }), acc, deq);
}

function fold_right_st(f, t, acc) {
  if (typeof t === "number") {
    return acc;
  } else if (t.TAG === /* T */0) {
    return fold_right_deque(f, t._0, acc);
  } else {
    return fold_left_deque((function (z, x) {
                  return Curry._2(f, x, z);
                }), acc, t._0);
  }
}

function fold_right_deque(f, deq, acc) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return fold_right_path(f, deq._0, acc);
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  var acc$1 = fold_right_path(f, deq._1, acc);
  return fold_right_path(f, deq._0, acc$1);
}

function fold_left_triple_h(f, acc, triple, kont) {
  var match = Deckrev_internal.triple_not_rev(triple);
  if (typeof match === "number") {
    var p = Deckrev_internal.triple_not_rev(kont);
    var exit = 0;
    if (typeof p === "number") {
      exit = 1;
    } else {
      switch (p.TAG | 0) {
        case /* Only_prefix */1 :
            return buffer_fold_left(f, acc, p._0);
        case /* Left_small */6 :
        case /* Right_small */11 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          var acc$1 = buffer_fold_left(f, acc, p._0);
          var acc$2 = fold_left_deque((function (param, param$1) {
                  return fold_left_stored_triple(f, param, param$1);
                }), acc$1, p._1);
          return buffer_fold_left(f, acc$2, p._2);
      case 2 :
          var acc$3 = buffer_fold_left(f, acc, p._0);
          return buffer_fold_left(f, acc$3, p._1);
      
    }
  }
  var acc$4 = buffer_fold_left(f, acc, match._0);
  var acc$5 = fold_left_nedeque((function (param, param$1) {
          return fold_left_stored_triple(f, param, param$1);
        }), acc$4, match._1, kont);
  return buffer_fold_left(f, acc$5, match._2);
}

function fold_left_deque(f, acc, deq) {
  switch (deq.TAG | 0) {
    case /* Only_path */0 :
        return fold_left_path(f, acc, deq._0);
    case /* Pair_green */1 :
    case /* Pair_red */2 :
        break;
    
  }
  var acc$1 = fold_left_path(f, acc, deq._0);
  return fold_left_path(f, acc$1, deq._1);
}

function fold_left_nedeque(f, acc, deq, kont) {
  var exit = 0;
  switch (deq.TAG | 0) {
    case /* Only_of */0 :
        return fold_left_triple_h(f, acc, deq._0, kont);
    case /* Pair_right */2 :
    case /* Pair_left_sym */3 :
        exit = 2;
        break;
    case /* Pair_left */1 :
    case /* Pair_right_sym */4 :
        exit = 1;
        break;
    
  }
  switch (exit) {
    case 1 :
        var acc$1 = fold_left_triple_h(f, acc, deq._0, kont);
        return fold_left_path(f, acc$1, deq._1);
    case 2 :
        var acc$2 = fold_left_path(f, acc, deq._0);
        return fold_left_triple_h(f, acc$2, deq._1, kont);
    
  }
}

function fold_left_path(f, acc, param) {
  return fold_left_triple_h(f, acc, param._0, param._1);
}

function fold_right_triple_h(f, triple, kont, acc) {
  var match = Deckrev_internal.triple_not_rev(triple);
  if (typeof match === "number") {
    var p = Deckrev_internal.triple_not_rev(kont);
    var exit = 0;
    if (typeof p === "number") {
      exit = 1;
    } else {
      switch (p.TAG | 0) {
        case /* Only_prefix */1 :
            return buffer_fold_right(f, p._0, acc);
        case /* Left_small */6 :
        case /* Right_small */11 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          var acc$1 = buffer_fold_right(f, p._2, acc);
          var acc$2 = fold_right_deque((function (param, param$1) {
                  return fold_right_stored_triple(f, param, param$1);
                }), p._1, acc$1);
          return buffer_fold_right(f, p._0, acc$2);
      case 2 :
          var acc$3 = buffer_fold_right(f, p._1, acc);
          return buffer_fold_right(f, p._0, acc$3);
      
    }
  }
  var acc$4 = buffer_fold_right(f, match._2, acc);
  var acc$5 = fold_right_nedeque((function (param, param$1) {
          return fold_right_stored_triple(f, param, param$1);
        }), match._1, kont, acc$4);
  return buffer_fold_right(f, match._0, acc$5);
}

function fold_left(f, z, t) {
  var f$1 = function (z, x) {
    return Curry._2(f, z, Deckrev_internal.unelt(x));
  };
  return fold_left_st(f$1, z, t._0);
}

function fold_right(f, t, z) {
  var f$1 = function (x, z) {
    return Curry._2(f, Deckrev_internal.unelt(x), z);
  };
  return fold_right_st(f$1, t._0, z);
}

function of_buffer(d) {
  var d$1 = Deckrev_internal.$$Buffer.of_dequeue(d);
  if (d$1) {
    return /* Regular */{
            _0: {
              TAG: /* T */0,
              _0: {
                TAG: /* Only_path */0,
                _0: /* Path */{
                  _0: /* HOLE */0,
                  _1: {
                    TAG: /* Only_prefix */1,
                    _0: d$1._0
                  }
                }
              }
            }
          };
  } else {
    return /* Regular */{
            _0: /* Void */0
          };
  }
}

function of_dequeue(d) {
  return of_buffer(Curry._2(Dequeue.map, (function (x) {
                    return {
                            TAG: /* L2R */0,
                            _0: x
                          };
                  }), d));
}

function make(n, x) {
  return of_buffer(Dequeue.make(n, {
                  TAG: /* L2R */0,
                  _0: x
                }));
}

function singleton(x) {
  return of_dequeue(Dequeue.singleton(x));
}

function length(t) {
  return fold_left((function (s, param) {
                return s + 1 | 0;
              }), 0, t);
}

var empty = Deckrev_internal.empty;

var is_empty = Deckrev_internal.is_empty;

var cons = Deckrev_internal.cons;

var uncons = Deckrev_internal.uncons;

var snoc = Deckrev_internal.snoc;

var unsnoc = Deckrev_internal.unsnoc;

var rev = Deckrev_internal.rev;

exports.empty = empty;
exports.is_empty = is_empty;
exports.singleton = singleton;
exports.cons = cons;
exports.uncons = uncons;
exports.snoc = snoc;
exports.unsnoc = unsnoc;
exports.append = append;
exports.rev = rev;
exports.length = length;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.of_dequeue = of_dequeue;
exports.make = make;
/* Dequeue Not a pure module */
