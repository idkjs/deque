// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("../src/List.bs.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Deque = require("../src/deque.bs.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");

var max_width = {
  contents: 80
};

function square(x) {
  return Math.imul(x, x);
}

function dynamic(words) {
  var words$1 = $$Array.of_list(words);
  var cache = $$Array.make_matrix(words$1.length, max_width.contents, -1);
  var cost_of = function (line) {
    var x = max_width.contents - line | 0;
    return Math.imul(x, x);
  };
  var go = function (word_index, _current_line_length) {
    while(true) {
      var current_line_length = _current_line_length;
      if (word_index >= words$1.length) {
        return 0;
      }
      if (current_line_length >= max_width.contents) {
        _current_line_length = 0;
        continue ;
      }
      if (Caml_array.get(Caml_array.get(cache, word_index), current_line_length) >= 0) {
        return Caml_array.get(Caml_array.get(cache, word_index), current_line_length);
      }
      var r = compute(word_index, current_line_length);
      Caml_array.set(Caml_array.get(cache, word_index), current_line_length, r);
      return r;
    };
  };
  var compute = function (word_index, current_line_length) {
    var w = Caml_array.get(words$1, word_index);
    var new_length = current_line_length === 0 ? w.length : (current_line_length + 1 | 0) + w.length | 0;
    var $$break = function (param) {
      return cost_of(current_line_length) + go(word_index, 0) | 0;
    };
    if (current_line_length === 0) {
      return go(word_index + 1 | 0, new_length);
    } else if (new_length > max_width.contents) {
      return $$break(undefined);
    } else {
      return Caml_primitive.caml_int_min(go(word_index + 1 | 0, new_length), $$break(undefined));
    }
  };
  return go(0, 0);
}

var empty_layout = {
  breaks: /* [] */0,
  cost: 0
};

function current_length(position, fmt) {
  var match = fmt.breaks;
  if (match) {
    return (position - match.hd | 0) - 1 | 0;
  } else {
    return position;
  }
}

function remaining(position, p) {
  return max_width.contents - current_length(position, p) | 0;
}

function add_word(w, position) {
  return (position + 1 | 0) + w.length | 0;
}

function futur_cost(position, p) {
  var x = remaining(position, p);
  return p.cost + Math.imul(x, x) | 0;
}

function add_break(position, fmt) {
  var x = max_width.contents - current_length(position, fmt) | 0;
  return {
          breaks: {
            hd: position,
            tl: fmt.breaks
          },
          cost: fmt.cost + Math.imul(x, x) | 0
        };
}

function drop_while(p, _xs) {
  while(true) {
    var xs = _xs;
    var match = Deque.Dequeue.uncons(xs);
    if (match === undefined) {
      return xs;
    }
    if (!Curry._1(p, match[0])) {
      return xs;
    }
    _xs = match[1];
    continue ;
  };
}

function nbr_chars(position, p, q) {
  var $slash$slash = function (a, b) {
    return Caml_int32.div(a, b) + (
            Caml_int32.mod_(a, b) > 0 ? 1 : 0
          ) | 0;
  };
  var i = $slash$slash(futur_cost(position, q) - futur_cost(position, p) | 0, ((remaining(position, q) - remaining(position, p) | 0) << 1));
  return Caml_primitive.caml_int_min(i, remaining(position, q));
}

function trim_tail(new_position, xs, p) {
  var match = Deque.Dequeue.unsnoc(xs);
  if (match !== undefined) {
    return trim_tail$prime(new_position, match[0], match[1], p);
  } else {
    return Deque.Dequeue.snoc(xs, p);
  }
}

function trim_tail$prime(new_position, _rest, _q, p) {
  while(true) {
    var q = _q;
    var rest = _rest;
    if (futur_cost(new_position, p) < futur_cost(new_position, q)) {
      return trim_tail(new_position, rest, p);
    }
    var match = Deque.Dequeue.unsnoc(rest);
    if (match !== undefined) {
      var r = match[1];
      if (nbr_chars(new_position, p, q) <= nbr_chars(new_position, q, r)) {
        _q = r;
        _rest = match[0];
        continue ;
      }
      
    }
    return Deque.Dequeue.snoc(Deque.Dequeue.snoc(rest, q), p);
  };
}

function trim_head$prime(position, _p, _xs, _p_xs) {
  while(true) {
    var p_xs = _p_xs;
    var xs = _xs;
    var p = _p;
    var match = Deque.Dequeue.uncons(xs);
    if (match === undefined) {
      return p_xs;
    }
    var q = match[0];
    if (futur_cost(position, p) < futur_cost(position, q)) {
      return p_xs;
    }
    _p_xs = xs;
    _xs = match[1];
    _p = q;
    continue ;
  };
}

function trim_head(position, xs) {
  var match = Deque.Dequeue.uncons(xs);
  if (match !== undefined) {
    return trim_head$prime(position, match[0], match[1], xs);
  } else {
    return xs;
  }
}

function overflow(position, c) {
  return current_length(position, c) > max_width.contents;
}

function step(position, candidates, word) {
  var new_position = add_word(word, position);
  var new_candidates = trim_head(new_position, drop_while((function (param) {
              return overflow(new_position, param);
            }), candidates));
  var new_candidates$1;
  if (position <= 0) {
    new_candidates$1 = new_candidates;
  } else {
    var match = Deque.Dequeue.uncons(candidates);
    if (match !== undefined) {
      var c = add_break(position, match[0]);
      new_candidates$1 = trim_tail(new_position, new_candidates, c);
    } else {
      new_candidates$1 = new_candidates;
    }
  }
  return [
          new_position,
          new_candidates$1
        ];
}

function all_layouts(words) {
  return List.fold_left((function (param, word) {
                  return step(param[0], param[1], word);
                }), [
                -1,
                Deque.Dequeue.cons(empty_layout, Deque.Dequeue.empty)
              ], words)[1];
}

function get_best(candidates) {
  var match = Deque.Dequeue.uncons(candidates);
  if (match !== undefined) {
    return Deque.Dequeue.fold_left((function (best, c) {
                  if (best.cost < c.cost) {
                    return best;
                  } else {
                    return c;
                  }
                }), match[0], match[1]);
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "knuth_plass.re",
          195,
          12
        ],
        Error: new Error()
      };
}

function knuth_plass(ws) {
  return get_best(all_layouts(ws));
}

function fmt(words, fmt$1) {
  Curry._1(Printf.printf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "COST: ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_i */3,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\n' */10,
                  _1: {
                    TAG: /* Flush */10,
                    _0: /* End_of_format */0
                  }
                }
              }
            },
            _1: "COST: %i\n%!"
          }), fmt$1.cost);
  Curry._1(Printf.printf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* Char_literal */12,
                _0: /* '\n' */10,
                _1: {
                  TAG: /* Flush */10,
                  _0: /* End_of_format */0
                }
              }
            },
            _1: "%s\n%!"
          }), $$String.make(max_width.contents, /* 'v' */118));
  var go = function (current_width, position, breaks, words) {
    if (!words) {
      return /* [] */0;
    }
    if (breaks && breaks.hd === position) {
      var w = words.hd;
      var filler = $$String.make(Caml_primitive.caml_int_max(0, max_width.contents - current_width | 0), /* '~' */126);
      var new_position = add_word(w, position);
      return {
              hd: filler,
              tl: {
                hd: "\n",
                tl: {
                  hd: w,
                  tl: go(add_word(w, -1), new_position, breaks.tl, words.tl)
                }
              }
            };
    }
    var w$1 = words.hd;
    var new_position$1 = add_word(w$1, position);
    var ws = go(add_word(w$1, current_width), new_position$1, breaks, words.tl);
    return {
            hd: " ",
            tl: {
              hd: w$1,
              tl: ws
            }
          };
  };
  var ok = go(-1, -1, List.rev(fmt$1.breaks), words);
  var res = ok && ok.hd === " " ? ok.tl : ok;
  List.iter(Printf.printf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), res);
  return Printf.printf(/* Format */{
              _0: {
                TAG: /* Char_literal */12,
                _0: /* '\n' */10,
                _1: {
                  TAG: /* Flush */10,
                  _0: /* End_of_format */0
                }
              },
              _1: "\n%!"
            });
}

function linear(words) {
  var step = function (param, w) {
    var layout = param[1];
    var position = param[0];
    var new_position = (position + 1 | 0) + w.length | 0;
    if (current_length(new_position, layout) > max_width.contents) {
      return [
              new_position,
              add_break(position, layout)
            ];
    } else {
      return [
              new_position,
              layout
            ];
    }
  };
  return List.fold_left(step, [
                -1,
                empty_layout
              ], words)[1];
}

function whitespace(prim) {
  return prim.trim();
}

function words(str) {
  var partial_arg = str.trim();
  return function (param) {
    return partial_arg.split(param);
  };
}

function test(str) {
  var ws = $$Array.to_list(words(str));
  for(var i = 20; i <= 70; ++i){
    max_width.contents = i;
    var opt = dynamic(ws);
    Curry._1(Printf.printf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "QUADRATIC DYNAMIC: ",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_i */3,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: {
                    TAG: /* Char_literal */12,
                    _0: /* '\n' */10,
                    _1: {
                      TAG: /* Flush */10,
                      _0: /* End_of_format */0
                    }
                  }
                }
              },
              _1: "QUADRATIC DYNAMIC: %i\n%!"
            }), opt);
    Printf.printf(/* Format */{
          _0: {
            TAG: /* String_literal */11,
            _0: " KNUTH PLASS ",
            _1: /* End_of_format */0
          },
          _1: " KNUTH PLASS "
        });
    var sol = get_best(all_layouts(ws));
    fmt(ws, sol);
    if (sol.cost !== opt) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "knuth_plass.re",
              263,
              4
            ],
            Error: new Error()
          };
    }
    Printf.printf(/* Format */{
          _0: {
            TAG: /* Char_literal */12,
            _0: /* '\n' */10,
            _1: {
              TAG: /* Flush */10,
              _0: /* End_of_format */0
            }
          },
          _1: "\n%!"
        });
    Printf.printf(/* Format */{
          _0: {
            TAG: /* String_literal */11,
            _0: "LINEAR ",
            _1: /* End_of_format */0
          },
          _1: "LINEAR "
        });
    var sol_linear = linear(ws);
    fmt(ws, sol_linear);
    if (sol_linear.cost < opt) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "knuth_plass.re",
              268,
              4
            ],
            Error: new Error()
          };
    }
    Printf.printf(/* Format */{
          _0: {
            TAG: /* Char_literal */12,
            _0: /* '\n' */10,
            _1: {
              TAG: /* Flush */10,
              _0: /* End_of_format */0
            }
          },
          _1: "\n%!"
        });
  }
  
}

var lorem = " Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas\n     fermentum, ligula in interdum iaculis, orci metus ullamcorper nisl,\n     in dapibus nulla turpis in orci. Cras pharetra neque vitae metus\n     fringilla, vitae sodales neque tristique. Suspendisse sed diam a arcu\n     rhoncus pretium nec a enim. Proin eget pulvinar neque. Nulla a sodales\n     felis, ac mattis nisi. Nulla ac massa fermentum, iaculis lorem a,\n     mattis est. Sed dignissim lectus sed consectetur volutpat. Vivamus\n     condimentum convallis ligula a tin cidunt. Sed in odio neque. Mauris\n     congue nisl consequat urna dictum hendrerit. Maecenas eu sagittis\n     lectus. Nunc rutrum varius sollicitudin. Curabitur lobortis gravida\n     turpis, vitae sollicitudin mi commodo et. Praesent sit amet imperdiet\n     turpis. Nullam facilisis ligula quis posuere sodales. a a a a a a a a\n     a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\n     a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\n     a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\n     a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\n     a a a a a a a a a a a a a a a\n     bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n  ";

test(lorem);

var Deque$1;

exports.max_width = max_width;
exports.square = square;
exports.dynamic = dynamic;
exports.empty_layout = empty_layout;
exports.current_length = current_length;
exports.remaining = remaining;
exports.add_word = add_word;
exports.futur_cost = futur_cost;
exports.add_break = add_break;
exports.Deque = Deque$1;
exports.drop_while = drop_while;
exports.nbr_chars = nbr_chars;
exports.trim_tail = trim_tail;
exports.trim_tail$prime = trim_tail$prime;
exports.trim_head = trim_head;
exports.trim_head$prime = trim_head$prime;
exports.overflow = overflow;
exports.step = step;
exports.all_layouts = all_layouts;
exports.get_best = get_best;
exports.knuth_plass = knuth_plass;
exports.fmt = fmt;
exports.linear = linear;
exports.whitespace = whitespace;
exports.words = words;
exports.test = test;
exports.lorem = lorem;
/*  Not a pure module */
